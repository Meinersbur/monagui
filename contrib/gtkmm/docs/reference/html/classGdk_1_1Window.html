<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gtkmm 2.4: Gdk::Window Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/gtkmm_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="http://www.gtkmm.org/documentation.shtml">Main Page</a> &nbsp;
  <a href="group__Widgets.html">Widgets</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
  <a href="../../tutorial/html/index.html"> Book</a> &nbsp;
</center>
<hr width="100%"/>
<!-- begin main content -->
<div id="content">
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespaceGdk.html">Gdk</a>::<a class="el" href="classGdk_1_1Window.html">Window</a>
  </div>
<div class="contents">
<h1>Gdk::Window Class Reference</h1><!-- doxytag: class="Gdk::Window" --><!-- doxytag: inherits="Gdk::Drawable" -->A <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> is a rectangular region on the screen.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for Gdk::Window:</div>
<div class="dynsection">
<p><center><img src="classGdk_1_1Window__inherit__graph.png" border="0" usemap="#Gdk_1_1Window__inherit__map" alt="Inheritance graph"></center>
<map name="Gdk_1_1Window__inherit__map">
<area shape="rect" href="classGdk_1_1Drawable.html" title="Drawing Primitives." alt="" coords="5,80,112,107"><area shape="rect" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/classGlib_1_1Object.html" title="Glib::Object" alt="" coords="13,5,104,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classGdk_1_1Window-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#413863a30bbac24d6d1a207401c07caf">add_filter</a> (GdkFilterFunc function, gpointer data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an event filter to <em>window</em>, allowing you to intercept events before they reach GDK.  <a href="#413863a30bbac24d6d1a207401c07caf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#fba92b3ac4244483186e68cc17ded2d5">beep</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits a short beep associated to <em>window</em> in the appropriate display, if supported.  <a href="#fba92b3ac4244483186e68cc17ded2d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#f6a0afd0f7d850e04a3cdc5d76115c56">begin_move_drag</a> (int button, int root_x, int root_y, guint32 timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins a window move operation (for a toplevel window).  <a href="#f6a0afd0f7d850e04a3cdc5d76115c56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#a0cc483d4278e4c7fb0cee2d109095ba">begin_paint_rect</a> (<a class="el" href="classGdk_1_1Rectangle.html">Rectangle</a>&amp; rectangle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper around gdk_window_begin_paint_region() which creates a rectangular region for you.  <a href="#a0cc483d4278e4c7fb0cee2d109095ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#e9b866577d6a20aa250b74a1144dca3f">begin_paint_region</a> (const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp; region)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that you are beginning the process of redrawing <em>region</em>.  <a href="#e9b866577d6a20aa250b74a1144dca3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#4e2292672c3e82f7b25503db8d9c0266">begin_resize_drag</a> (<a class="el" href="group__gdkmmEnums.html#ge31896bd6d904848c07ef7f929063c0c">WindowEdge</a> edge, int button, int root_x, int root_y, guint32 timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins a window resize operation (for a toplevel window).  <a href="#4e2292672c3e82f7b25503db8d9c0266"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#62057e2fe9726f664dd01319e645f7b1">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears an entire <em>window</em> to the background color or background pixmap.  <a href="#62057e2fe9726f664dd01319e645f7b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#5d0030ccfb0a62bd6d734c49cb706a51">clear_area</a> (int x, int y, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears an area of <em>window</em> to the background color or background pixmap.  <a href="#5d0030ccfb0a62bd6d734c49cb706a51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#1b9659f60941e5f14b3497409d03409a">clear_area_e</a> (int x, int y, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like gdk_window_clear_area(), but also generates an expose event for the cleared area.  <a href="#1b9659f60941e5f14b3497409d03409a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#ebb7266930dad01675f28abe8e5c4cf1">configure_finished</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal to the window system that the application has finished handling Configure events it has received.  <a href="#ebb7266930dad01675f28abe8e5c4cf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#2c43698b27dc5e31b4c7c1ca76496a03">deiconify</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to deiconify (unminimize) <em>window</em>.  <a href="#2c43698b27dc5e31b4c7c1ca76496a03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#356e4e19207606e91f87346a378e1b1f">enable_synchronized_configure</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that the application will cooperate with the window system in synchronizing the window repaint with the window manager during resizing operations.  <a href="#356e4e19207606e91f87346a378e1b1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#21c920c3f5903e7d338b68c68f09e645">end_paint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that the backing store created by the most recent call to gdk_window_begin_paint_region() should be copied onscreen and deleted, leaving the next-most-recent backing store or no backing store at all as the active paint region.  <a href="#21c920c3f5903e7d338b68c68f09e645"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#7b30990c3efc8d50215fcb6f8cde0546">focus</a> (guint32 timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets keyboard focus to <em>window</em>.  <a href="#7b30990c3efc8d50215fcb6f8cde0546"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#15ebab2c454f75f0a5342542626cbdde">freeze_updates</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporarily freezes a window such that it won't receive expose events.  <a href="#15ebab2c454f75f0a5342542626cbdde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#09a8cf95b58f8cdcc819d6064f6dc984">fullscreen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the window into fullscreen mode.  <a href="#09a8cf95b58f8cdcc819d6064f6dc984"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ListHandle&lt; Glib::RefPtr<br class="typebreak">
&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a> &gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#058a3a892228ea6b061b27d0b4bc5f90">get_children</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the list of children of <em>window</em> known to GDK.  <a href="#058a3a892228ea6b061b27d0b4bc5f90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ListHandle&lt; Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGdk_1_1Window.html">Window</a> &gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#64ed74dec0ef11678a2b70286da1c3dc">get_children</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the list of children of <em>window</em> known to GDK.  <a href="#64ed74dec0ef11678a2b70286da1c3dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#f006eb45e3ce4884a731a33913493290">get_decorations</a> (<a class="el" href="group__gdkmmEnums.html#g1164863f498802821810010d1f3202a4">WMDecoration</a>&amp; decorations) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns: <code>true</code> if the window has decorations set, <code>false</code> otherwise.  <a href="#f006eb45e3ce4884a731a33913493290"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#41eaa04d1b75d309be5be8639b1bf1b0">get_events</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the event mask for <em>window</em>.  <a href="#41eaa04d1b75d309be5be8639b1bf1b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#b518e9b6a14392722f71cb2174c40d55">get_frame_extents</a> (<a class="el" href="classGdk_1_1Rectangle.html">Rectangle</a>&amp; rect)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the bounding box of the window, including window manager titlebar/borders if any.  <a href="#b518e9b6a14392722f71cb2174c40d55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6833d29726c3d995c39b74310d21326e">get_geometry</a> (int&amp; x, int&amp; y, int&amp; width, int&amp; height, int&amp; depth) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Any of the return location arguments to this function may be <code>0</code>, if you aren't interested in getting the value of that field.  <a href="#6833d29726c3d995c39b74310d21326e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#1faf6b134e161a09ad9ce937585176bd">get_group</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: the group leader window for <em>window</em>.  <a href="#1faf6b134e161a09ad9ce937585176bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#d151acb64c1a34158cd3ace71889f260">get_group</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: the group leader window for <em>window</em>.  <a href="#d151acb64c1a34158cd3ace71889f260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#9a88b194ecdcee52fd7d37118d5375db">get_internal_paint_info</a> (Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Drawable.html">Drawable</a>&gt;&amp; real_drawable, int&amp; x_offset, int&amp; y_offset) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#f7eef7c273c02fbc0fd02c075b57309f">get_origin</a> (int&amp; x, int&amp; y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the position of a window in root window coordinates.  <a href="#f7eef7c273c02fbc0fd02c075b57309f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#b5485601dc363c5aa40862113a1a40ff">get_parent</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the parent of <em>window</em>, as known to GDK.  <a href="#b5485601dc363c5aa40862113a1a40ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#c09f2facb64137aa5b05623c2b41063a">get_parent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the parent of <em>window</em>, as known to GDK.  <a href="#c09f2facb64137aa5b05623c2b41063a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#7b72ec86d47d628bd9112a803d61089f">get_pointer</a> (int&amp; x, int&amp; y, <a class="el" href="group__gdkmmEnums.html#g734c2979005c87dbe51223a0128cdd97">ModifierType</a>&amp; mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the current pointer position and modifier state.  <a href="#7b72ec86d47d628bd9112a803d61089f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#86dcf2d6fe032353e1ef76c69887dae7">get_position</a> (int&amp; x, int&amp; y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the position of the window as reported in the most-recently-processed Gdk::EventConfigure.  <a href="#86dcf2d6fe032353e1ef76c69887dae7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#e886fd01bfaa25d1c843bafeb745790f">get_root_origin</a> (int&amp; x, int&amp; y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the top-left corner of the window manager frame in root window coordinates.  <a href="#e886fd01bfaa25d1c843bafeb745790f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#g52281110716dc2727d7f1e8303f9b950">WindowState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#0e3921982caec87dedde90140e134d3f">get_state</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the bitwise OR of the currently active window state flags, from the <a class="el" href="group__gdkmmEnums.html#g52281110716dc2727d7f1e8303f9b950">Gdk::WindowState</a> enumeration.  <a href="#0e3921982caec87dedde90140e134d3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#025df98a25bb99ef3144004cb9547878">get_toplevel</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the toplevel window that's an ancestor of <em>window</em>.  <a href="#025df98a25bb99ef3144004cb9547878"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#13b651e86823b82bb7c06249b30f95de">get_toplevel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the toplevel window that's an ancestor of <em>window</em>.  <a href="#13b651e86823b82bb7c06249b30f95de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#g1f75a8db0f289997ac16bba0891776c9">WindowTypeHint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#7c0dd035d50de014a5abe8b0a41b82b7">get_type_hint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the type hint set for a window.  <a href="#7c0dd035d50de014a5abe8b0a41b82b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGdk_1_1Region.html">Region</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6145bbac95071f5783752504d169c7b4">get_update_area</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfers ownership of the update area from <em>window</em> to the caller of the function.  <a href="#6145bbac95071f5783752504d169c7b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#82d50ebb9c1f2bce00437eecc3f2b21c">get_user_data</a> (gpointer* data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the user data for <em>window</em>, which is normally the widget that <em>window</em> belongs to.  <a href="#82d50ebb9c1f2bce00437eecc3f2b21c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#g2b9f4daf18d16a75d9bfe279f5340c02">WindowType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#a5d6f691b65a70deae5ee6d5883e9a6d">get_window_type</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the type of the window.  <a href="#a5d6f691b65a70deae5ee6d5883e9a6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const GdkWindow*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#9cd1fbdc140ff77e1b005938bd439f49">gobj</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#9cd1fbdc140ff77e1b005938bd439f49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GdkWindow*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#0bc9fc92bac3c509b0a0d754488903b0">gobj</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#0bc9fc92bac3c509b0a0d754488903b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GdkWindow*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#ddb464bdf61c63040afe7bae6d1ed4bf">gobj_copy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#ddb464bdf61c63040afe7bae6d1ed4bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#2850d6c550e5c2f73f82fe0043b091b1">hide</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For toplevel windows, withdraws them, so they will no longer be known to the window manager; for all windows, unmaps them, so they won't be displayed.  <a href="#2850d6c550e5c2f73f82fe0043b091b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6d14f032c5f40a83ded5e9817cafaae3">iconify</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks to iconify (minimize) <em>window</em>.  <a href="#6d14f032c5f40a83ded5e9817cafaae3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#4b0c0b20adc4bcf3f0e4d665059573d3">input_shape_combine_mask</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Bitmap.html">Bitmap</a>&gt;&amp; mask, int x, int y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like gdk_window_shape_combine_mask(), but the shape applies only to event handling.  <a href="#4b0c0b20adc4bcf3f0e4d665059573d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#fca024064999914065da4014a14a9f17">input_shape_combine_region</a> (const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp; shape_region, int offset_x, int offset_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like gdk_window_shape_combine_region(), but the shape applies only to event handling.  <a href="#fca024064999914065da4014a14a9f17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#fd705d134dd0753dfd5d76bcb4988c27">invalidate_rect</a> (const <a class="el" href="classGdk_1_1Rectangle.html">Rectangle</a>&amp; rect, bool invalidate_children)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper around gdk_window_invalidate_region() which invalidates a rectangular region.  <a href="#fd705d134dd0753dfd5d76bcb4988c27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#1a68d500a7be88de01d87e781aa2be89">invalidate_region</a> (const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp; region, bool invalidate_children=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <em>region</em> to the update area for <em>window</em>.  <a href="#1a68d500a7be88de01d87e781aa2be89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#9e4506546231e69eebebc398627de723">is_viewable</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the window and all ancestors of the window are mapped.  <a href="#9e4506546231e69eebebc398627de723"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#44d6daf9e5cd55b18891a5173956d3bf">is_visible</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the window has been mapped (with gdk_window_show() or gdk_window_show_unraised()).  <a href="#44d6daf9e5cd55b18891a5173956d3bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#eece1b9a0e700b161b86471843a906ac">keyboard_grab</a> (bool owner_events, guint32 timestamp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#275d4424691fee615c469f7c6bdd59bf">lower</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowers <em>window</em> to the bottom of the Z-order (stacking order), so that other windows with the same parent window appear above <em>window</em>.  <a href="#275d4424691fee615c469f7c6bdd59bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#4cc88ddb51aff3135603a5282073f625">maximize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximizes the window.  <a href="#4cc88ddb51aff3135603a5282073f625"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#df4f0442926e39a327843a6b5946e4c5">merge_child_input_shapes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges the input shape masks for any child windows into the input shape mask for <em>window</em>.  <a href="#df4f0442926e39a327843a6b5946e4c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#48118e2ebc867bc3c726d85f5eec0659">merge_child_shapes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges the shape masks for any child windows into the shape mask for <em>window</em>.  <a href="#48118e2ebc867bc3c726d85f5eec0659"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#bdaf2a58abef5b8bc4f7a36d7109076e">move</a> (int x, int y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Repositions a window relative to its parent window.  <a href="#bdaf2a58abef5b8bc4f7a36d7109076e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#1c1e8c3af5bdd711be6ef487ff01cd8a">move_region</a> (const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp; region, int dx, int dy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the part of <em>window</em> indicated by <em>region</em> by <em>dy</em> pixels in the Y direction and <em>dx</em> pixels in the X direction.  <a href="#1c1e8c3af5bdd711be6ef487ff01cd8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#fa7df5ed11a3b022c567e644d64ada07">move_resize</a> (int x, int y, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equivalent to calling gdk_window_move() and gdk_window_resize(), except that both operations are performed at once, avoiding strange visual effects.  <a href="#fa7df5ed11a3b022c567e644d64ada07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#2bcea48b9e4a8f747f8c6ace58fc4651">pointer_grab</a> (bool owner_events, <a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a> event_mask, guint32 timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grabs the pointer to a specific window.  <a href="#2bcea48b9e4a8f747f8c6ace58fc4651"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#a448a6cd06d1421d519d78da43ae6b8f">pointer_grab</a> (bool owner_events, <a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a> event_mask, const <a class="el" href="classGdk_1_1Cursor.html">Cursor</a>&amp; cursor, guint32 timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grabs the pointer to a specific window.  <a href="#a448a6cd06d1421d519d78da43ae6b8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6bcc579d9de9494524681890e69147c7">pointer_grab</a> (bool owner_events, <a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a> event_mask, const Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; confine_to, const <a class="el" href="classGdk_1_1Cursor.html">Cursor</a>&amp; cursor, guint32 time_)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6ec5f7e788470159672511c964771285">process_updates</a> (bool update_children)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends one or more expose events to <em>window</em>.  <a href="#6ec5f7e788470159672511c964771285"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6eef65b862344ad01b01e527f2c39741">raise</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raises <em>window</em> to the top of the Z-order (stacking order), so that other windows with the same parent window appear below <em>window</em>.  <a href="#6eef65b862344ad01b01e527f2c39741"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#53a80a911aab9875900da568c57b0cee">register_dnd</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#a0b04aed6d338ce78f10060b025ceb3f">remove_filter</a> (GdkFilterFunc function, gpointer data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a filter previously added with gdk_window_add_filter().  <a href="#a0b04aed6d338ce78f10060b025ceb3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#1de4d3f12a7f2e7e866f1d9909a9a001">reparent</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; new_parent, int x, int y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reparents <em>window</em> into the given <em>new_parent</em>.  <a href="#1de4d3f12a7f2e7e866f1d9909a9a001"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#c24547040d1662585c8ee64fe56780f6">resize</a> (int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes <em>window</em>; for toplevel windows, asks the window manager to resize the window.  <a href="#c24547040d1662585c8ee64fe56780f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#7c96ca3674bbf8dbd71602d2f7893b8e">scroll</a> (int dx, int dy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scroll the contents of <em>window</em>, both pixels and children, by the given amount.  <a href="#7c96ca3674bbf8dbd71602d2f7893b8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#cb1d7d6cbd6691a38b699a39d2eecc30">set_accept_focus</a> (bool accept_focus=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting <em>accept_focus</em> to <code>false</code> hints the desktop environment that the window doesn't want to receive input focus.  <a href="#cb1d7d6cbd6691a38b699a39d2eecc30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#27f458f963e431f559b0b64c3134e40c">set_back_pixmap</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixmap.html">Pixmap</a>&gt;&amp; pixmap, bool parent_relative=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the background pixmap of <em>window</em>.  <a href="#27f458f963e431f559b0b64c3134e40c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#3beabdcf6f6f2c36f03288aaba209863">set_background</a> (const <a class="el" href="classGdk_1_1Color.html">Color</a>&amp; color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the background color of <em>window</em>.  <a href="#3beabdcf6f6f2c36f03288aaba209863"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#4c4a3eff84349ff97ecf1d24972cc751">set_child_input_shapes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the input shape mask of <em>window</em> to the union of input shape masks for all children of <em>window</em>, ignoring the input shape mask of <em>window</em> itself.  <a href="#4c4a3eff84349ff97ecf1d24972cc751"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#0573c6c2876784956e463eccebb55c6f">set_child_shapes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the shape mask of <em>window</em> to the union of shape masks for all children of <em>window</em>, ignoring the shape mask of <em>window</em> itself.  <a href="#0573c6c2876784956e463eccebb55c6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#ba9d5bea3de05b31eff0da2bed753db8">set_composited</a> (bool composited=TRUE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> as composited, or unsets it.  <a href="#ba9d5bea3de05b31eff0da2bed753db8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#ba9323e496965a473e37566140cc9a10">set_cursor</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the parent window's cursor.  <a href="#ba9323e496965a473e37566140cc9a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#bb73b1f599ce6cb72d2e184c63610fd0">set_cursor</a> (const <a class="el" href="classGdk_1_1Cursor.html">Cursor</a>&amp; cursor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mouse pointer for a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>.  <a href="#bb73b1f599ce6cb72d2e184c63610fd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#851f5cf4a7e203d8f6f6078818b7f80d">set_decorations</a> (<a class="el" href="group__gdkmmEnums.html#g1164863f498802821810010d1f3202a4">WMDecoration</a> decorations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Decorations" are the features the window manager adds to a toplevel <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>.  <a href="#851f5cf4a7e203d8f6f6078818b7f80d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#be022e72429562865fa0d31587056890">set_events</a> (<a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a> event_mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The event mask for a window determines which events will be reported for that window.  <a href="#be022e72429562865fa0d31587056890"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#df1d9237560226bc8b78ae48c9172e08">set_focus_on_map</a> (bool focus_on_map)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting <em>focus_on_map</em> to <code>false</code> hints the desktop environment that the window doesn't want to receive input focus when it is mapped.  <a href="#df1d9237560226bc8b78ae48c9172e08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#2ada3527bed8ba03670d83203c09a446">set_functions</a> (<a class="el" href="group__gdkmmEnums.html#ge86c2fc4eac7ecb9c6c9dd841b1ba6af">WMFunction</a> functions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets hints about the window management functions to make available via buttons on the window frame.  <a href="#2ada3527bed8ba03670d83203c09a446"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6ec3d94409fddef481e3e57714c577fa">set_geometry_hints</a> (const <a class="el" href="namespaceGdk.html#f6948e754cab4e79c6430fb94e438d83">Geometry</a>&amp; geometry, <a class="el" href="group__gdkmmEnums.html#g7dd31e80216f3452a1e080bd22fcfd9c">WindowHints</a> geom_mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the geometry hints for <em>window</em>.  <a href="#6ec3d94409fddef481e3e57714c577fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#c45fc54f035a56f9b8c6a1f5a8a63ed3">set_group</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; leader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the group leader window for <em>window</em>.  <a href="#c45fc54f035a56f9b8c6a1f5a8a63ed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#8eba9690001e09932eccc46c08aff05c">set_icon</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; icon_window, const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixmap.html">Pixmap</a>&gt;&amp; pixmap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#0f9e1a266aec25fb998accc03c90d6c4">set_icon</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; icon_window, const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixmap.html">Pixmap</a>&gt;&amp; pixmap, const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Bitmap.html">Bitmap</a>&gt;&amp; mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the icon of <em>window</em> as a pixmap or window.  <a href="#0f9e1a266aec25fb998accc03c90d6c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#afd2706d1abf1f2ed0de4cbb3708d7cb">set_icon_list</a> (const Glib::ListHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&gt;&amp; pixbufs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a list of icons for the window.  <a href="#afd2706d1abf1f2ed0de4cbb3708d7cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#c5e3fbd4f07bed0a5060b32a07a127b6">set_icon_name</a> (const Glib::ustring&amp; name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Windows may have a name used while minimized, distinct from the name they display in their titlebar.  <a href="#c5e3fbd4f07bed0a5060b32a07a127b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#2e961a8cba7b796e7787ab1857340ded">set_keep_above</a> (bool setting=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set if <em>window</em> must be kept above other windows.  <a href="#2e961a8cba7b796e7787ab1857340ded"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#1e740ff027fc23170a1fd3cd12cbd3d0">set_keep_below</a> (bool setting=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set if <em>window</em> must be kept below other windows.  <a href="#1e740ff027fc23170a1fd3cd12cbd3d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#22dc81b0749d30bbbdf5906059459482">set_modal_hint</a> (bool modal=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The application can use this hint to tell the window manager that a certain window has modal behaviour.  <a href="#22dc81b0749d30bbbdf5906059459482"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#f70da6bc12c5997b6cd77f4cd14e5129">set_opacity</a> (double opacity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request the windowing system to make <em>window</em> partially transparent, with opacity 0 being fully transparent and 1 fully opaque.  <a href="#f70da6bc12c5997b6cd77f4cd14e5129"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#ad09335b20323d81cb214e549ba201e6">set_override_redirect</a> (bool override_redirect=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An override redirect window is not under the control of the window manager.  <a href="#ad09335b20323d81cb214e549ba201e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#f0af1130cfb882913b80d9a82123479e">set_role</a> (const Glib::ustring&amp; role)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When using GTK+, typically you should use gtk_window_set_role() instead of this low-level function.  <a href="#f0af1130cfb882913b80d9a82123479e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#a4900976eda16fc8a6280eb0bd325f8c">set_skip_pager_hint</a> (bool skips_pager=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggles whether a window should appear in a pager (workspace switcher, or other desktop utility program that displays a small thumbnail representation of the windows on the desktop).  <a href="#a4900976eda16fc8a6280eb0bd325f8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#34b9d99e30afd4e4106d66408d007fdd">set_skip_taskbar_hint</a> (bool skips_taskbar=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggles whether a window should appear in a task list or window list.  <a href="#34b9d99e30afd4e4106d66408d007fdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#246b2c39068bf02f4e981fde58f8d776">set_startup_id</a> (const Glib::ustring&amp; startup_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When using GTK+, typically you should use gtk_window_set_startup_id() instead of this low-level function.  <a href="#246b2c39068bf02f4e981fde58f8d776"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#7886467cef616c0c07ba482888490059">set_static_gravities</a> (bool use_static=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the bit gravity of the given window to static, and flag it so all children get static subwindow gravity.  <a href="#7886467cef616c0c07ba482888490059"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#89c47b105ce213eb1b075d1c8dd34ab6">set_title</a> (const Glib::ustring&amp; title)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the title of a toplevel window, to be displayed in the titlebar.  <a href="#89c47b105ce213eb1b075d1c8dd34ab6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#b8e6f4a6758057f249a41eccb3c59061">set_transient_for</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the window manager that <em>window</em> is a transient dialog associated with the application window <em>parent</em>.  <a href="#b8e6f4a6758057f249a41eccb3c59061"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#4505331d1882e0e02d076782ddfaa2ff">set_type_hint</a> (<a class="el" href="group__gdkmmEnums.html#g1f75a8db0f289997ac16bba0891776c9">WindowTypeHint</a> hint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The application can use this call to provide a hint to the window manager about the functionality of a window.  <a href="#4505331d1882e0e02d076782ddfaa2ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#9f22c1db8469dbe6fa8229e80d344434">set_urgency_hint</a> (bool urgent=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggles whether a window needs the user's urgent attention.  <a href="#9f22c1db8469dbe6fa8229e80d344434"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#6e895c78858224262b90564b68759b62">set_user_data</a> (gpointer user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For most purposes this function is deprecated in favor of Glib::object_set_data().  <a href="#6e895c78858224262b90564b68759b62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#7e7ccbbb8a86215d0478b9fc041dce34">shape_combine_mask</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Bitmap.html">Bitmap</a>&gt;&amp; mask, int x, int y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a shape mask to <em>window</em>.  <a href="#7e7ccbbb8a86215d0478b9fc041dce34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#4ddecf82c0b07e4ad106caf90f17ca8f">shape_combine_region</a> (const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp; shape_region, int offset_x, int offset_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes pixels in <em>window</em> outside <em>shape_region</em> be transparent, so that the window may be nonrectangular.  <a href="#4ddecf82c0b07e4ad106caf90f17ca8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#d850f17e45522107fb498de8641766f7">show</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like gdk_window_show_unraised(), but also raises the window to the top of the window stack (moves the window to the front of the Z-order).  <a href="#d850f17e45522107fb498de8641766f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#2c6d829cf3fc060ab52a4bdc7d77973a">show_unraised</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shows a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> onscreen, but does not modify its stacking order.  <a href="#2c6d829cf3fc060ab52a4bdc7d77973a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#72cddee1b5ed8a663b6f245e59132473">stick</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Pins" a window such that it's on all workspaces and does not scroll with viewports, for window managers that have scrollable viewports.  <a href="#72cddee1b5ed8a663b6f245e59132473"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#128616c32cb210b0181a74d6f6bfa4a5">thaw_updates</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thaws a window frozen with <a class="el" href="classGdk_1_1Window.html#15ebab2c454f75f0a5342542626cbdde" title="Temporarily freezes a window such that it won&#39;t receive expose events.">Gdk::Window::freeze_updates()</a>.  <a href="#128616c32cb210b0181a74d6f6bfa4a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#46d71da2107832855f8d047b3effbb67">unfullscreen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the window out of fullscreen mode.  <a href="#46d71da2107832855f8d047b3effbb67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#d9325d93af96ee6774ffa4fa354d1d25">unmaximize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmaximizes the window.  <a href="#d9325d93af96ee6774ffa4fa354d1d25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#729b9a7dfc3d4da8bfb0761d78b626d4">unset_back_pixmap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsets the background pixmap of <em>window</em> so that the window will have no background.  <a href="#729b9a7dfc3d4da8bfb0761d78b626d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#700b396befa605d159f2cd697a1f6014">unset_icon</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#8f3bfc50b1db35f74e9af21fc81591a0">unset_shape_combine_mask</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#22e499aeadc19f7373972355ae2872cb">unstick</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse operation for gdk_window_stick(); see gdk_window_stick(), and gtk_window_unstick().  <a href="#22e499aeadc19f7373972355ae2872cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#a7a5705224d062fe6351a426781597fa">withdraw</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Withdraws a window (unmaps it and asks the window manager to forget about it).  <a href="#a7a5705224d062fe6351a426781597fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#84984d0d1a1a4dd893133a80fbd25ec5">~Window</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#79cdc422025b7ce7be99ef20ff20bafe">constrain_size</a> (const <a class="el" href="namespaceGdk.html#f6948e754cab4e79c6430fb94e438d83">Geometry</a>&amp; geometry, guint flags, int width, int height, int&amp; new_width, int&amp; new_height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constrains a desired width and height according to a set of geometry hints (such as minimum and maximum size).  <a href="#79cdc422025b7ce7be99ef20ff20bafe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#4895a2e0fd6d5dcc1c6f1ffe712c65a6">create</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; parent, GdkWindowAttr* attributes, int attributes_mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static Glib::ListHandle<br class="typebreak">
&lt;Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#bdcf6aa7127b2e1911fc6773b801a2fc">get_toplevels</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains a list of all toplevel windows known to GDK on the default screen (see gdk_window_get_toplevels_for_screen()).  <a href="#bdcf6aa7127b2e1911fc6773b801a2fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#d9a73b6b522030512fb87acd9739eda9">keyboard_ungrab</a> (guint32 timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ungrabs the keyboard on the default display, if it is grabbed by this application.  <a href="#d9a73b6b522030512fb87acd9739eda9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#c8586f7f64a088277347ac0725bbe2c0">pointer_ungrab</a> (guint32 timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ungrabs the pointer on the default display, if it is grabbed by this application.  <a href="#c8586f7f64a088277347ac0725bbe2c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#3fc76fbdf9948b92dacfd1a9e340184b">process_all_updates</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls gdk_window_process_updates() for all windows (see <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>) in the application.  <a href="#3fc76fbdf9948b92dacfd1a9e340184b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#736baef4396a9255cc820ba60245769a">set_debug_updates</a> (bool setting=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">With update debugging enabled, calls to gdk_window_invalidate_region() clear the invalidated region of the screen to a noticeable color, and GDK pauses for a short time before sending exposes to windows during gdk_window_process_updates().  <a href="#736baef4396a9255cc820ba60245769a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#5c7958efa9bf3499bf411bff07edc39d">set_sm_client_id</a> (const Glib::ustring&amp; sm_client_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the <code>SM_CLIENT_ID</code> property on the application's leader window so that the window manager can save the application's state using the X11R6 ICCCM session management protocol.  <a href="#5c7958efa9bf3499bf411bff07edc39d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#b8b3893818a244b31fed8460586cd2d6">unset_sm_client_id</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#8442ac0f1bfbfcdd748903685589fa5e">Window</a> (const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp; parent, GdkWindowAttr* attributes, int attributes_mask)</td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Gdk::Window</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGdk_1_1Window.html#c7eeaceb12343803db90524716bf7bd0">wrap</a> (GdkWindowObject* object, bool take_copy=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Glib::wrap() method for this object.  <a href="#c7eeaceb12343803db90524716bf7bd0"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> is a rectangular region on the screen. 
<p>
It's a low-level object, used to implement high-level objects such as <a class="el" href="classGtk_1_1Widget.html" title="Abstract Widget (Base class for all widgets).">Gtk::Widget</a> and <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a> on the GTK+ level. A <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a> is a toplevel window, the thing a user might think of as a "window" with a titlebar and so on; a <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a> may contain many Gdk::Windows. For example, each <a class="el" href="classGtk_1_1Button.html" title="A widget that creates a signal when clicked on.">Gtk::Button</a> has a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> associated with it. <hr><h2>Constructor&amp; Destructor Documentation</h2>
<a class="anchor" name="84984d0d1a1a4dd893133a80fbd25ec5"></a><!-- doxytag: member="Gdk::Window::~Window" ref="84984d0d1a1a4dd893133a80fbd25ec5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gdk::Window::~Window           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8442ac0f1bfbfcdd748903685589fa5e"></a><!-- doxytag: member="Gdk::Window::Window" ref="8442ac0f1bfbfcdd748903685589fa5e" args="(const Glib::RefPtr&lt; Window &gt; &amp;parent, GdkWindowAttr *attributes, int attributes_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gdk::Window::Window           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GdkWindowAttr *&nbsp;</td>
          <td class="paramname"> <em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attributes_mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="413863a30bbac24d6d1a207401c07caf"></a><!-- doxytag: member="Gdk::Window::add_filter" ref="413863a30bbac24d6d1a207401c07caf" args="(GdkFilterFunc function, gpointer data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::add_filter           </td>
          <td>(</td>
          <td class="paramtype">GdkFilterFunc&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an event filter to <em>window</em>, allowing you to intercept events before they reach GDK. 
<p>
This is a low-level operation and makes it easy to break GDK and/or GTK+, so you have to know what you're doing. Pass <code>0</code> for <em>window</em> to get all events for all windows, instead of events for a specific window.<p>
See <a class="el" href="classGdk_1_1Display.html#6c4f9ccf0ed0da91dd2d88f7a58aa73d" title="Adds a filter to be called when X ClientMessage events are received.">Gdk::Display::add_client_message_filter()</a> if you are interested in X ClientMessage events. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>Filter callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data to pass to filter callback. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fba92b3ac4244483186e68cc17ded2d5"></a><!-- doxytag: member="Gdk::Window::beep" ref="fba92b3ac4244483186e68cc17ded2d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::beep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits a short beep associated to <em>window</em> in the appropriate display, if supported. 
<p>
Otherwise, emits a short beep on the display just as <a class="el" href="classGdk_1_1Display.html#63ff8a09aa81f2bf1f7581ddba39fe69" title="Emits a short beep on display.">Gdk::Display::beep()</a>.<p>
<dl compact><dt><b><a class="el" href="newin2p12s.html#_newin2p12s000015">Since gtkmm 2.12:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="f6a0afd0f7d850e04a3cdc5d76115c56"></a><!-- doxytag: member="Gdk::Window::begin_move_drag" ref="f6a0afd0f7d850e04a3cdc5d76115c56" args="(int button, int root_x, int root_y, guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::begin_move_drag           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a window move operation (for a toplevel window). 
<p>
You might use this function to implement a "window move grip," for example. The function works best with window managers that support the Extended <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Window</a> Manager Hints, but has a fallback implementation for other window managers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td>The button being used to drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_x</em>&nbsp;</td><td>Root window X coordinate of mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_y</em>&nbsp;</td><td>Root window Y coordinate of mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>Timestamp of mouse click that began the drag. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a0cc483d4278e4c7fb0cee2d109095ba"></a><!-- doxytag: member="Gdk::Window::begin_paint_rect" ref="a0cc483d4278e4c7fb0cee2d109095ba" args="(Rectangle &amp;rectangle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::begin_paint_rect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGdk_1_1Rectangle.html">Rectangle</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience wrapper around gdk_window_begin_paint_region() which creates a rectangular region for you. 
<p>
See gdk_window_begin_paint_region() for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangle</em>&nbsp;</td><td><a class="el" href="classGdk_1_1Rectangle.html" title="Gdk::Rectangle is a structure holding the position and size of a rectangle.">Rectangle</a> you intend to draw to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e9b866577d6a20aa250b74a1144dca3f"></a><!-- doxytag: member="Gdk::Window::begin_paint_region" ref="e9b866577d6a20aa250b74a1144dca3f" args="(const Region &amp;region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::begin_paint_region           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that you are beginning the process of redrawing <em>region</em>. 
<p>
A backing store (offscreen buffer) large enough to contain <em>region</em> will be created. The backing store will be initialized with the background color or background pixmap for <em>window</em>. Then, all drawing operations performed on <em>window</em> will be diverted to the backing store. When you call gdk_window_end_paint(), the backing store will be copied to <em>window</em>, making it visible onscreen. Only the part of <em>window</em> contained in <em>region</em> will be modified; that is, drawing operations are clipped to <em>region</em>.<p>
The net result of all this is to remove flicker, because the user sees the finished product appear all at once when you call gdk_window_end_paint(). If you draw to <em>window</em> directly without calling gdk_window_begin_paint_region(), the user may see flicker as individual drawing operations are performed in sequence. The clipping and background-initializing features of gdk_window_begin_paint_region() are conveniences for the programmer, so you can avoid doing that work yourself.<p>
When using GTK+, the widget system automatically places calls to gdk_window_begin_paint_region() and gdk_window_end_paint() around emissions of the expose_event signal. That is, if you're writing an expose event handler, you can assume that the exposed area in Gdk::EventExpose has already been cleared to the window background, is already set as the clip region, and already has a backing store. Therefore in most cases, application code need not call gdk_window_begin_paint_region(). (You can disable the automatic calls around expose events on a widget-by-widget basis by calling gtk_widget_set_double_buffered().)<p>
If you call this function multiple times before calling the matching gdk_window_end_paint(), the backing stores are pushed onto a stack. gdk_window_end_paint() copies the topmost backing store onscreen, subtracts the topmost region from all other regions in the stack, and pops the stack. All drawing operations affect only the topmost backing store in the stack. One matching call to gdk_window_end_paint() is required for each call to gdk_window_begin_paint_region(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td><a class="el" href="classGdk_1_1Region.html" title="This is an opaque data type holding a set of arbitrary pixels, and is usually used...">Region</a> you intend to draw to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4e2292672c3e82f7b25503db8d9c0266"></a><!-- doxytag: member="Gdk::Window::begin_resize_drag" ref="4e2292672c3e82f7b25503db8d9c0266" args="(WindowEdge edge, int button, int root_x, int root_y, guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::begin_resize_drag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#ge31896bd6d904848c07ef7f929063c0c">WindowEdge</a>&nbsp;</td>
          <td class="paramname"> <em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a window resize operation (for a toplevel window). 
<p>
You might use this function to implement a "window resize grip," for example; in fact <a class="el" href="classGtk_1_1Statusbar.html" title="Text status indicator This widget is used to display status information.">Gtk::Statusbar</a> uses it. The function works best with window managers that support the Extended <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Window</a> Manager Hints, but has a fallback implementation for other window managers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>The edge or corner from which the drag is started. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td>The button being used to drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_x</em>&nbsp;</td><td>Root window X coordinate of mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_y</em>&nbsp;</td><td>Root window Y coordinate of mouse click that began the drag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>Timestamp of mouse click that began the drag (use gdk_event_get_time()). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="62057e2fe9726f664dd01319e645f7b1"></a><!-- doxytag: member="Gdk::Window::clear" ref="62057e2fe9726f664dd01319e645f7b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears an entire <em>window</em> to the background color or background pixmap. 
<p>

</div>
</div><p>
<a class="anchor" name="5d0030ccfb0a62bd6d734c49cb706a51"></a><!-- doxytag: member="Gdk::Window::clear_area" ref="5d0030ccfb0a62bd6d734c49cb706a51" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::clear_area           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears an area of <em>window</em> to the background color or background pixmap. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X coordinate of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y coordinate of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of rectangle to clear. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1b9659f60941e5f14b3497409d03409a"></a><!-- doxytag: member="Gdk::Window::clear_area_e" ref="1b9659f60941e5f14b3497409d03409a" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::clear_area_e           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like gdk_window_clear_area(), but also generates an expose event for the cleared area. 
<p>
This function has a stupid name because it dates back to the mists time, pre-GDK-1.0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X coordinate of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y coordinate of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of rectangle to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of rectangle to clear. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ebb7266930dad01675f28abe8e5c4cf1"></a><!-- doxytag: member="Gdk::Window::configure_finished" ref="ebb7266930dad01675f28abe8e5c4cf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::configure_finished           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal to the window system that the application has finished handling Configure events it has received. 
<p>
<a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Window</a> Managers can use this to better synchronize the frame repaint with the application. GTK+ applications will automatically call this function when appropriate.<p>
This function can only be called if gdk_window_enable_synchronized_configure() was called previously.<p>
<dl compact><dt><b><a class="el" href="newin2p6s.html#_newin2p6s000013">Since gtkmm 2.6:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="79cdc422025b7ce7be99ef20ff20bafe"></a><!-- doxytag: member="Gdk::Window::constrain_size" ref="79cdc422025b7ce7be99ef20ff20bafe" args="(const Geometry &amp;geometry, guint flags, int width, int height, int &amp;new_width, int &amp;new_height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gdk::Window::constrain_size           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGdk.html#f6948e754cab4e79c6430fb94e438d83">Geometry</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>new_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>new_height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constrains a desired width and height according to a set of geometry hints (such as minimum and maximum size). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry</em>&nbsp;</td><td>A <a class="el" href="namespaceGdk.html#f6948e754cab4e79c6430fb94e438d83">Gdk::Geometry</a> structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A mask indicating what portions of <em>geometry</em> are set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Desired width of window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Desired height of the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_width</em>&nbsp;</td><td>Location to store resulting width. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_height</em>&nbsp;</td><td>Location to store resulting height. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4895a2e0fd6d5dcc1c6f1ffe712c65a6"></a><!-- doxytag: member="Gdk::Window::create" ref="4895a2e0fd6d5dcc1c6f1ffe712c65a6" args="(const Glib::RefPtr&lt; Window &gt; &amp;parent, GdkWindowAttr *attributes, int attributes_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::create           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GdkWindowAttr *&nbsp;</td>
          <td class="paramname"> <em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attributes_mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2c43698b27dc5e31b4c7c1ca76496a03"></a><!-- doxytag: member="Gdk::Window::deiconify" ref="2c43698b27dc5e31b4c7c1ca76496a03" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::deiconify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to deiconify (unminimize) <em>window</em>. 
<p>
On X11 the window manager may choose to ignore the request to deiconify. When using GTK+, use gtk_window_deiconify() instead of the <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> variant. Or better yet, you probably want to use gtk_window_present(), which raises the window, focuses it, unminimizes it, and puts it on the current desktop. 
</div>
</div><p>
<a class="anchor" name="356e4e19207606e91f87346a378e1b1f"></a><!-- doxytag: member="Gdk::Window::enable_synchronized_configure" ref="356e4e19207606e91f87346a378e1b1f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::enable_synchronized_configure           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that the application will cooperate with the window system in synchronizing the window repaint with the window manager during resizing operations. 
<p>
After an application calls this function, it must call gdk_window_configure_finished() every time it has finished all processing associated with a set of Configure events. Toplevel GTK+ windows automatically use this protocol.<p>
On X, calling this function makes <em>window</em> participate in the _NET_WM_SYNC_REQUEST window manager protocol.<p>
<dl compact><dt><b><a class="el" href="newin2p6s.html#_newin2p6s000012">Since gtkmm 2.6:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="21c920c3f5903e7d338b68c68f09e645"></a><!-- doxytag: member="Gdk::Window::end_paint" ref="21c920c3f5903e7d338b68c68f09e645" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::end_paint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that the backing store created by the most recent call to gdk_window_begin_paint_region() should be copied onscreen and deleted, leaving the next-most-recent backing store or no backing store at all as the active paint region. 
<p>
See gdk_window_begin_paint_region() for full details. It is an error to call this function without a matching gdk_window_begin_paint_region() first. 
</div>
</div><p>
<a class="anchor" name="7b30990c3efc8d50215fcb6f8cde0546"></a><!-- doxytag: member="Gdk::Window::focus" ref="7b30990c3efc8d50215fcb6f8cde0546" args="(guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::focus           </td>
          <td>(</td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets keyboard focus to <em>window</em>. 
<p>
In most cases, gtk_window_present() should be used on a <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a>, rather than calling this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>Timestamp of the event triggering the window focus. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="15ebab2c454f75f0a5342542626cbdde"></a><!-- doxytag: member="Gdk::Window::freeze_updates" ref="15ebab2c454f75f0a5342542626cbdde" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::freeze_updates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Temporarily freezes a window such that it won't receive expose events. 
<p>
The window will begin receiving expose events again when <a class="el" href="classGdk_1_1Window.html#128616c32cb210b0181a74d6f6bfa4a5" title="Thaws a window frozen with Gdk::Window::freeze_updates().">Gdk::Window::thaw_updates()</a> is called. If <a class="el" href="classGdk_1_1Window.html#15ebab2c454f75f0a5342542626cbdde" title="Temporarily freezes a window such that it won&#39;t receive expose events.">Gdk::Window::freeze_updates()</a> has been called more than once, <a class="el" href="classGdk_1_1Window.html#128616c32cb210b0181a74d6f6bfa4a5" title="Thaws a window frozen with Gdk::Window::freeze_updates().">Gdk::Window::thaw_updates()</a> must be called an equal number of times to begin processing exposes. 
</div>
</div><p>
<a class="anchor" name="09a8cf95b58f8cdcc819d6064f6dc984"></a><!-- doxytag: member="Gdk::Window::fullscreen" ref="09a8cf95b58f8cdcc819d6064f6dc984" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::fullscreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the window into fullscreen mode. 
<p>
This means the window covers the entire screen and is above any panels or task bars.<p>
If the window was already fullscreen, then this function does nothing.<p>
On X11, asks the window manager to put <em>window</em> in a fullscreen state, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "fullscreen"; so you can't rely on the fullscreenification actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.<p>
<dl compact><dt><b><a class="el" href="newin2p2s.html#_newin2p2s000091">Since gtkmm 2.2:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="058a3a892228ea6b061b27d0b4bc5f90"></a><!-- doxytag: member="Gdk::Window::get_children" ref="058a3a892228ea6b061b27d0b4bc5f90" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ListHandle&lt;Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&gt; Gdk::Window::get_children           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the list of children of <em>window</em> known to GDK. 
<p>
This function only returns children created via GDK, so for example it's useless when used with the root window; it only returns windows an application created itself.<p>
The returned list must be freed, but the elements in the list need not be. <dl class="return" compact><dt><b>Returns:</b></dt><dd>List of child windows inside <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64ed74dec0ef11678a2b70286da1c3dc"></a><!-- doxytag: member="Gdk::Window::get_children" ref="64ed74dec0ef11678a2b70286da1c3dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ListHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&gt; Gdk::Window::get_children           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the list of children of <em>window</em> known to GDK. 
<p>
This function only returns children created via GDK, so for example it's useless when used with the root window; it only returns windows an application created itself.<p>
The returned list must be freed, but the elements in the list need not be. <dl class="return" compact><dt><b>Returns:</b></dt><dd>List of child windows inside <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f006eb45e3ce4884a731a33913493290"></a><!-- doxytag: member="Gdk::Window::get_decorations" ref="f006eb45e3ce4884a731a33913493290" args="(WMDecoration &amp;decorations) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gdk::Window::get_decorations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g1164863f498802821810010d1f3202a4">WMDecoration</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>decorations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns: <code>true</code> if the window has decorations set, <code>false</code> otherwise. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>decorations</em>&nbsp;</td><td>The window decorations will be written here. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the window has decorations set, <code>false</code> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41eaa04d1b75d309be5be8639b1bf1b0"></a><!-- doxytag: member="Gdk::Window::get_events" ref="41eaa04d1b75d309be5be8639b1bf1b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a> Gdk::Window::get_events           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the event mask for <em>window</em>. 
<p>
See gdk_window_set_events(). <dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classGdk_1_1Event.html">Event</a> mask for <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b518e9b6a14392722f71cb2174c40d55"></a><!-- doxytag: member="Gdk::Window::get_frame_extents" ref="b518e9b6a14392722f71cb2174c40d55" args="(Rectangle &amp;rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::get_frame_extents           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGdk_1_1Rectangle.html">Rectangle</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the bounding box of the window, including window manager titlebar/borders if any. 
<p>
The frame position is given in root window coordinates. To get the position of the window itself (rather than the frame) in root window coordinates, use gdk_window_get_origin(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td><a class="el" href="classGdk_1_1Rectangle.html" title="Gdk::Rectangle is a structure holding the position and size of a rectangle.">Rectangle</a> to fill with bounding box of the window frame. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6833d29726c3d995c39b74310d21326e"></a><!-- doxytag: member="Gdk::Window::get_geometry" ref="6833d29726c3d995c39b74310d21326e" args="(int &amp;x, int &amp;y, int &amp;width, int &amp;height, int &amp;depth) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::get_geometry           </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Any of the return location arguments to this function may be <code>0</code>, if you aren't interested in getting the value of that field. 
<p>
The X and Y coordinates returned are relative to the parent window of <em>window</em>, which for toplevels usually means relative to the window decorations (titlebar, etc.) rather than relative to the root window (screen-size background window).<p>
On the X11 platform, the geometry is obtained from the X server, so reflects the latest position of <em>window</em>; this may be out-of-sync with the position of <em>window</em> delivered in the most-recently-processed Gdk::EventConfigure. gdk_window_get_position() in contrast gets the position from the most recent configure event.<p>
&lt;note&gt; If <em>window</em> is not a toplevel, it is <em>much</em> better to call gdk_window_get_position() and <a class="el" href="classGdk_1_1Drawable.html#938f9da906aafcfa089a9aab8e30749d" title="Fills* width and* height with the size of drawable.">Gdk::Drawable::get_size()</a> instead, because it avoids the roundtrip to the X server and because <a class="el" href="classGdk_1_1Drawable.html#938f9da906aafcfa089a9aab8e30749d" title="Fills* width and* height with the size of drawable.">Gdk::Drawable::get_size()</a> supports the full 32-bit coordinate space, whereas gdk_window_get_geometry() is restricted to the 16-bit coordinates of X11. &lt;/note&gt; <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Return location for X coordinate of window (relative to its parent). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Return location for Y coordinate of window (relative to its parent). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Return location for width of window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Return location for height of window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Return location for bit depth of window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1faf6b134e161a09ad9ce937585176bd"></a><!-- doxytag: member="Gdk::Window::get_group" ref="1faf6b134e161a09ad9ce937585176bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::get_group           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: the group leader window for <em>window</em>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The group leader window for <em>window</em> </dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000010">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="d151acb64c1a34158cd3ace71889f260"></a><!-- doxytag: member="Gdk::Window::get_group" ref="d151acb64c1a34158cd3ace71889f260" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::get_group           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: the group leader window for <em>window</em>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The group leader window for <em>window</em> </dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000009">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="9a88b194ecdcee52fd7d37118d5375db"></a><!-- doxytag: member="Gdk::Window::get_internal_paint_info" ref="9a88b194ecdcee52fd7d37118d5375db" args="(Glib::RefPtr&lt; Drawable &gt; &amp;real_drawable, int &amp;x_offset, int &amp;y_offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::get_internal_paint_info           </td>
          <td>(</td>
          <td class="paramtype">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Drawable.html">Drawable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>real_drawable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>y_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f7eef7c273c02fbc0fd02c075b57309f"></a><!-- doxytag: member="Gdk::Window::get_origin" ref="f7eef7c273c02fbc0fd02c075b57309f" args="(int &amp;x, int &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gdk::Window::get_origin           </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the position of a window in root window coordinates. 
<p>
(Compare with gdk_window_get_position() and gdk_window_get_geometry() which return the position of a window relative to its parent window.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Return location for X coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Return location for Y coordinate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Not meaningful, ignore. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5485601dc363c5aa40862113a1a40ff"></a><!-- doxytag: member="Gdk::Window::get_parent" ref="b5485601dc363c5aa40862113a1a40ff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::get_parent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the parent of <em>window</em>, as known to GDK. 
<p>
Does not query the X server; thus this returns the parent as passed to gdk_window_new(), not the actual parent. This should never matter unless you're using Xlib calls mixed with GDK calls on the X11 platform. It may also matter for toplevel windows, because the window manager may choose to reparent them. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Parent of <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c09f2facb64137aa5b05623c2b41063a"></a><!-- doxytag: member="Gdk::Window::get_parent" ref="c09f2facb64137aa5b05623c2b41063a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::get_parent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the parent of <em>window</em>, as known to GDK. 
<p>
Does not query the X server; thus this returns the parent as passed to gdk_window_new(), not the actual parent. This should never matter unless you're using Xlib calls mixed with GDK calls on the X11 platform. It may also matter for toplevel windows, because the window manager may choose to reparent them. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Parent of <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b72ec86d47d628bd9112a803d61089f"></a><!-- doxytag: member="Gdk::Window::get_pointer" ref="7b72ec86d47d628bd9112a803d61089f" args="(int &amp;x, int &amp;y, ModifierType &amp;mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::get_pointer           </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g734c2979005c87dbe51223a0128cdd97">ModifierType</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the current pointer position and modifier state. 
<p>
The position is given in coordinates relative to the upper left corner of <em>window</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Return location for X coordinate of pointer or <code>0</code> to not return the X coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Return location for Y coordinate of pointer or <code>0</code> to not return the Y coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Return location for modifier mask or <code>0</code> to not return the modifier mask. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The window containing the pointer (as with gdk_window_at_pointer()), or <code>0</code> if the window containing the pointer isn't known to GDK. </dd></dl>

</div>
</div><p>
<a class="anchor" name="86dcf2d6fe032353e1ef76c69887dae7"></a><!-- doxytag: member="Gdk::Window::get_position" ref="86dcf2d6fe032353e1ef76c69887dae7" args="(int &amp;x, int &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::get_position           </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the position of the window as reported in the most-recently-processed Gdk::EventConfigure. 
<p>
Contrast with gdk_window_get_geometry() which queries the X server for the current window position, regardless of which events have been received or processed.<p>
The position coordinates are relative to the window's parent window. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X coordinate of window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y coordinate of window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e886fd01bfaa25d1c843bafeb745790f"></a><!-- doxytag: member="Gdk::Window::get_root_origin" ref="e886fd01bfaa25d1c843bafeb745790f" args="(int &amp;x, int &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::get_root_origin           </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the top-left corner of the window manager frame in root window coordinates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Return location for X position of window frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Return location for Y position of window frame. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e3921982caec87dedde90140e134d3f"></a><!-- doxytag: member="Gdk::Window::get_state" ref="0e3921982caec87dedde90140e134d3f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#g52281110716dc2727d7f1e8303f9b950">WindowState</a> Gdk::Window::get_state           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the bitwise OR of the currently active window state flags, from the <a class="el" href="group__gdkmmEnums.html#g52281110716dc2727d7f1e8303f9b950">Gdk::WindowState</a> enumeration. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Window</a> state bitfield. </dd></dl>

</div>
</div><p>
<a class="anchor" name="025df98a25bb99ef3144004cb9547878"></a><!-- doxytag: member="Gdk::Window::get_toplevel" ref="025df98a25bb99ef3144004cb9547878" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::get_toplevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the toplevel window that's an ancestor of <em>window</em>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The toplevel window containing <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="13b651e86823b82bb7c06249b30f95de"></a><!-- doxytag: member="Gdk::Window::get_toplevel" ref="13b651e86823b82bb7c06249b30f95de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt; Gdk::Window::get_toplevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the toplevel window that's an ancestor of <em>window</em>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The toplevel window containing <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bdcf6aa7127b2e1911fc6773b801a2fc"></a><!-- doxytag: member="Gdk::Window::get_toplevels" ref="bdcf6aa7127b2e1911fc6773b801a2fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Glib::ListHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&gt; Gdk::Window::get_toplevels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains a list of all toplevel windows known to GDK on the default screen (see gdk_window_get_toplevels_for_screen()). 
<p>
A toplevel window is a child of the root window (see gdk_get_default_root_window()). <dl class="return" compact><dt><b>Returns:</b></dt><dd>List of toplevel windows. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c0dd035d50de014a5abe8b0a41b82b7"></a><!-- doxytag: member="Gdk::Window::get_type_hint" ref="7c0dd035d50de014a5abe8b0a41b82b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#g1f75a8db0f289997ac16bba0891776c9">WindowTypeHint</a> Gdk::Window::get_type_hint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the type hint set for a window. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type hint set for <em>window</em> </dd></dl>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000021">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="6145bbac95071f5783752504d169c7b4"></a><!-- doxytag: member="Gdk::Window::get_update_area" ref="6145bbac95071f5783752504d169c7b4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGdk_1_1Region.html">Region</a> Gdk::Window::get_update_area           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transfers ownership of the update area from <em>window</em> to the caller of the function. 
<p>
That is, after calling this function, <em>window</em> will no longer have an invalid/dirty region; the update area is removed from <em>window</em> and handed to you. If a window has no update area, <a class="el" href="classGdk_1_1Window.html#6145bbac95071f5783752504d169c7b4" title="Transfers ownership of the update area from window to the caller of the function...">get_update_area()</a> returns an invalid <a class="el" href="classGdk_1_1Region.html" title="This is an opaque data type holding a set of arbitrary pixels, and is usually used...">Region</a>. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The update area for <em>window</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="82d50ebb9c1f2bce00437eecc3f2b21c"></a><!-- doxytag: member="Gdk::Window::get_user_data" ref="82d50ebb9c1f2bce00437eecc3f2b21c" args="(gpointer *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::get_user_data           </td>
          <td>(</td>
          <td class="paramtype">gpointer *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the user data for <em>window</em>, which is normally the widget that <em>window</em> belongs to. 
<p>
See gdk_window_set_user_data(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Return location for user data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5d6f691b65a70deae5ee6d5883e9a6d"></a><!-- doxytag: member="Gdk::Window::get_window_type" ref="a5d6f691b65a70deae5ee6d5883e9a6d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#g2b9f4daf18d16a75d9bfe279f5340c02">WindowType</a> Gdk::Window::get_window_type           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the type of the window. 
<p>
See <a class="el" href="group__gdkmmEnums.html#g2b9f4daf18d16a75d9bfe279f5340c02">Gdk::WindowType</a>. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Type of window. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cd1fbdc140ff77e1b005938bd439f49"></a><!-- doxytag: member="Gdk::Window::gobj" ref="9cd1fbdc140ff77e1b005938bd439f49" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GdkWindow* Gdk::Window::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGdk_1_1Drawable.html#42a8fa022e5ba2b06e3cfd0f2a9b656f">Gdk::Drawable</a>.</p>

</div>
</div><p>
<a class="anchor" name="0bc9fc92bac3c509b0a0d754488903b0"></a><!-- doxytag: member="Gdk::Window::gobj" ref="0bc9fc92bac3c509b0a0d754488903b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GdkWindow* Gdk::Window::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGdk_1_1Drawable.html#935facc32f620b59c0cfb2e1fd1f5675">Gdk::Drawable</a>.</p>

</div>
</div><p>
<a class="anchor" name="ddb464bdf61c63040afe7bae6d1ed4bf"></a><!-- doxytag: member="Gdk::Window::gobj_copy" ref="ddb464bdf61c63040afe7bae6d1ed4bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GdkWindow* Gdk::Window::gobj_copy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. 
<p>

<p>Reimplemented from <a class="el" href="classGdk_1_1Drawable.html#1500131ec8c995df7f20203c885ca4a8">Gdk::Drawable</a>.</p>

</div>
</div><p>
<a class="anchor" name="2850d6c550e5c2f73f82fe0043b091b1"></a><!-- doxytag: member="Gdk::Window::hide" ref="2850d6c550e5c2f73f82fe0043b091b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::hide           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For toplevel windows, withdraws them, so they will no longer be known to the window manager; for all windows, unmaps them, so they won't be displayed. 
<p>
Normally done automatically as part of gtk_widget_hide(). 
</div>
</div><p>
<a class="anchor" name="6d14f032c5f40a83ded5e9817cafaae3"></a><!-- doxytag: member="Gdk::Window::iconify" ref="6d14f032c5f40a83ded5e9817cafaae3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::iconify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks to iconify (minimize) <em>window</em>. 
<p>
The window manager may choose to ignore the request, but normally will honor it. Using gtk_window_iconify() is preferred, if you have a <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a> widget.<p>
This function only makes sense when <em>window</em> is a toplevel window. 
</div>
</div><p>
<a class="anchor" name="4b0c0b20adc4bcf3f0e4d665059573d3"></a><!-- doxytag: member="Gdk::Window::input_shape_combine_mask" ref="4b0c0b20adc4bcf3f0e4d665059573d3" args="(const Glib::RefPtr&lt; Bitmap &gt; &amp;mask, int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::input_shape_combine_mask           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Bitmap.html">Bitmap</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like gdk_window_shape_combine_mask(), but the shape applies only to event handling. 
<p>
Mouse events which happen while the pointer position corresponds to an unset bit in the mask will be passed on the window below <em>window</em>.<p>
An input shape is typically used with RGBA windows. The alpha channel of the window defines which pixels are invisible and allows for nicely antialiased borders, and the input shape controls where the window is "clickable".<p>
On the X11 platform, this requires version 1.1 of the shape extension.<p>
On the Win32 platform, this functionality is not present and the function does nothing.<p>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000017">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Shape mask. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X position of shape mask with respect to <em>window</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y position of shape mask with respect to <em>window</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fca024064999914065da4014a14a9f17"></a><!-- doxytag: member="Gdk::Window::input_shape_combine_region" ref="fca024064999914065da4014a14a9f17" args="(const Region &amp;shape_region, int offset_x, int offset_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::input_shape_combine_region           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>shape_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like gdk_window_shape_combine_region(), but the shape applies only to event handling. 
<p>
Mouse events which happen while the pointer position corresponds to an unset bit in the mask will be passed on the window below <em>window</em>.<p>
An input shape is typically used with RGBA windows. The alpha channel of the window defines which pixels are invisible and allows for nicely antialiased borders, and the input shape controls where the window is "clickable".<p>
On the X11 platform, this requires version 1.1 of the shape extension.<p>
On the Win32 platform, this functionality is not present and the function does nothing.<p>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000018">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shape_region</em>&nbsp;</td><td><a class="el" href="classGdk_1_1Region.html" title="This is an opaque data type holding a set of arbitrary pixels, and is usually used...">Region</a> of window to be non-transparent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>X position of <em>shape_region</em> in <em>window</em> coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>Y position of <em>shape_region</em> in <em>window</em> coordinates. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fd705d134dd0753dfd5d76bcb4988c27"></a><!-- doxytag: member="Gdk::Window::invalidate_rect" ref="fd705d134dd0753dfd5d76bcb4988c27" args="(const Rectangle &amp;rect, bool invalidate_children)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::invalidate_rect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Rectangle.html">Rectangle</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>invalidate_children</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience wrapper around gdk_window_invalidate_region() which invalidates a rectangular region. 
<p>
See gdk_window_invalidate_region() for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td><a class="el" href="classGdk_1_1Rectangle.html" title="Gdk::Rectangle is a structure holding the position and size of a rectangle.">Rectangle</a> to invalidate or <code>0</code> to invalidate the whole window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>invalidate_children</em>&nbsp;</td><td>Whether to also invalidate child windows. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1a68d500a7be88de01d87e781aa2be89"></a><!-- doxytag: member="Gdk::Window::invalidate_region" ref="1a68d500a7be88de01d87e781aa2be89" args="(const Region &amp;region, bool invalidate_children=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::invalidate_region           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>invalidate_children</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <em>region</em> to the update area for <em>window</em>. 
<p>
The update area is the region that needs to be redrawn, or "dirty region." The call gdk_window_process_updates() sends one or more expose events to the window, which together cover the entire update area. An application would normally redraw the contents of <em>window</em> in response to those expose events.<p>
GDK will call gdk_window_process_all_updates() on your behalf whenever your program returns to the main loop and becomes idle, so normally there's no need to do that manually, you just need to invalidate regions that you know should be redrawn.<p>
The <em>invalidate_children</em> parameter controls whether the region of each child window that intersects <em>region</em> will also be invalidated. If <code>false</code>, then the update area for child windows will remain unaffected. See gdk_window_invalidate_maybe_recurse if you need fine grained control over which children are invalidated. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>A <a class="el" href="classGdk_1_1Region.html" title="This is an opaque data type holding a set of arbitrary pixels, and is usually used...">Gdk::Region</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>invalidate_children</em>&nbsp;</td><td><code>true</code> to also invalidate child windows. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9e4506546231e69eebebc398627de723"></a><!-- doxytag: member="Gdk::Window::is_viewable" ref="9e4506546231e69eebebc398627de723" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gdk::Window::is_viewable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the window and all ancestors of the window are mapped. 
<p>
(This is not necessarily "viewable" in the X sense, since we only check as far as we have GDK window parents, not to the root window.) <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the window is viewable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="44d6daf9e5cd55b18891a5173956d3bf"></a><!-- doxytag: member="Gdk::Window::is_visible" ref="44d6daf9e5cd55b18891a5173956d3bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gdk::Window::is_visible           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether the window has been mapped (with gdk_window_show() or gdk_window_show_unraised()). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the window is mapped. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eece1b9a0e700b161b86471843a906ac"></a><!-- doxytag: member="Gdk::Window::keyboard_grab" ref="eece1b9a0e700b161b86471843a906ac" args="(bool owner_events, guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a> Gdk::Window::keyboard_grab           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d9a73b6b522030512fb87acd9739eda9"></a><!-- doxytag: member="Gdk::Window::keyboard_ungrab" ref="d9a73b6b522030512fb87acd9739eda9" args="(guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gdk::Window::keyboard_ungrab           </td>
          <td>(</td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ungrabs the keyboard on the default display, if it is grabbed by this application. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>A timestamp from a <a class="el" href="classGdk_1_1Event.html">Gdk::Event</a>, or Gdk::CURRENT_TIME if no timestamp is available. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="275d4424691fee615c469f7c6bdd59bf"></a><!-- doxytag: member="Gdk::Window::lower" ref="275d4424691fee615c469f7c6bdd59bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::lower           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lowers <em>window</em> to the bottom of the Z-order (stacking order), so that other windows with the same parent window appear above <em>window</em>. 
<p>
This is true whether or not the other windows are visible.<p>
If <em>window</em> is a toplevel, the window manager may choose to deny the request to move the window in the Z-order, gdk_window_lower() only requests the restack, does not guarantee it.<p>
Note that gdk_window_show() raises the window again, so don't call this function before gdk_window_show(). (Try gdk_window_show_unraised().) 
</div>
</div><p>
<a class="anchor" name="4cc88ddb51aff3135603a5282073f625"></a><!-- doxytag: member="Gdk::Window::maximize" ref="4cc88ddb51aff3135603a5282073f625" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::maximize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximizes the window. 
<p>
If the window was already maximized, then this function does nothing.<p>
On X11, asks the window manager to maximize <em>window</em>, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "maximized"; so you can't rely on the maximization actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.<p>
On Windows, reliably maximizes the window. 
</div>
</div><p>
<a class="anchor" name="df4f0442926e39a327843a6b5946e4c5"></a><!-- doxytag: member="Gdk::Window::merge_child_input_shapes" ref="df4f0442926e39a327843a6b5946e4c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::merge_child_input_shapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges the input shape masks for any child windows into the input shape mask for <em>window</em>. 
<p>
i.e. the union of all input masks for <em>window</em> and its children will become the new input mask for <em>window</em>. See gdk_window_input_shape_combine_mask().<p>
This function is distinct from gdk_window_set_child_input_shapes() because it includes <em>window's</em> input shape mask in the set of shapes to be merged.<p>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000020">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="48118e2ebc867bc3c726d85f5eec0659"></a><!-- doxytag: member="Gdk::Window::merge_child_shapes" ref="48118e2ebc867bc3c726d85f5eec0659" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::merge_child_shapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges the shape masks for any child windows into the shape mask for <em>window</em>. 
<p>
i.e. the union of all masks for <em>window</em> and its children will become the new mask for <em>window</em>. See gdk_window_shape_combine_mask().<p>
This function is distinct from gdk_window_set_child_shapes() because it includes <em>window's</em> shape mask in the set of shapes to be merged. 
</div>
</div><p>
<a class="anchor" name="bdaf2a58abef5b8bc4f7a36d7109076e"></a><!-- doxytag: member="Gdk::Window::move" ref="bdaf2a58abef5b8bc4f7a36d7109076e" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::move           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Repositions a window relative to its parent window. 
<p>
For toplevel windows, window managers may ignore or modify the move; you should probably use gtk_window_move() on a <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a> widget anyway, instead of using GDK functions. For child windows, the move will reliably succeed.<p>
If you're also planning to resize the window, use gdk_window_move_resize() to both move and resize simultaneously, for a nicer visual effect. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X coordinate relative to window's parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y coordinate relative to window's parent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1c1e8c3af5bdd711be6ef487ff01cd8a"></a><!-- doxytag: member="Gdk::Window::move_region" ref="1c1e8c3af5bdd711be6ef487ff01cd8a" args="(const Region &amp;region, int dx, int dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::move_region           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move the part of <em>window</em> indicated by <em>region</em> by <em>dy</em> pixels in the Y direction and <em>dx</em> pixels in the X direction. 
<p>
The portions of <em>region</em> that not covered by the new position of <em>region</em> are invalidated.<p>
Child windows are not moved.<p>
<dl compact><dt><b><a class="el" href="newin2p8s.html#_newin2p8s000008">Since gtkmm 2.8:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The <a class="el" href="classGdk_1_1Region.html" title="This is an opaque data type holding a set of arbitrary pixels, and is usually used...">Gdk::Region</a> to move. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>Amount to move in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>Amount to move in the Y direction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa7df5ed11a3b022c567e644d64ada07"></a><!-- doxytag: member="Gdk::Window::move_resize" ref="fa7df5ed11a3b022c567e644d64ada07" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::move_resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to calling gdk_window_move() and gdk_window_resize(), except that both operations are performed at once, avoiding strange visual effects. 
<p>
(i.e. the user may be able to see the window first move, then resize, if you don't use gdk_window_move_resize().) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>New X position relative to window's parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>New Y position relative to window's parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>New width. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>New height. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2bcea48b9e4a8f747f8c6ace58fc4651"></a><!-- doxytag: member="Gdk::Window::pointer_grab" ref="2bcea48b9e4a8f747f8c6ace58fc4651" args="(bool owner_events, EventMask event_mask, guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a> Gdk::Window::pointer_grab           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a>&nbsp;</td>
          <td class="paramname"> <em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grabs the pointer to a specific window. 
<p>
Requires a corresponding call to <a class="el" href="classGdk_1_1Window.html#c8586f7f64a088277347ac0725bbe2c0" title="Ungrabs the pointer on the default display, if it is grabbed by this application...">pointer_ungrab()</a>.<p>
Arguments: <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_events</em>&nbsp;</td><td>Specifies whether events will be reported as is, or relative to the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event_mask</em>&nbsp;</td><td>Masks only interesting events. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>Specifies the time. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a448a6cd06d1421d519d78da43ae6b8f"></a><!-- doxytag: member="Gdk::Window::pointer_grab" ref="a448a6cd06d1421d519d78da43ae6b8f" args="(bool owner_events, EventMask event_mask, const Cursor &amp;cursor, guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a> Gdk::Window::pointer_grab           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a>&nbsp;</td>
          <td class="paramname"> <em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Cursor.html">Cursor</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grabs the pointer to a specific window. 
<p>
Requires a corresponding call to <a class="el" href="classGdk_1_1Window.html#c8586f7f64a088277347ac0725bbe2c0" title="Ungrabs the pointer on the default display, if it is grabbed by this application...">pointer_ungrab()</a>.<p>
Arguments: <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_events</em>&nbsp;</td><td>Specifies whether events will be reported as is, or relative to the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event_mask</em>&nbsp;</td><td>Masks only interesting events. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td>Changes the cursor for the duration of the grab. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>Specifies the time. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6bcc579d9de9494524681890e69147c7"></a><!-- doxytag: member="Gdk::Window::pointer_grab" ref="6bcc579d9de9494524681890e69147c7" args="(bool owner_events, EventMask event_mask, const Glib::RefPtr&lt; const Window &gt; &amp;confine_to, const Cursor &amp;cursor, guint32 time_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gdkmmEnums.html#gb3918cc69c861b97779ac08dfa48610f">GrabStatus</a> Gdk::Window::pointer_grab           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>owner_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a>&nbsp;</td>
          <td class="paramname"> <em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;const <a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>confine_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Cursor.html">Cursor</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>time_</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c8586f7f64a088277347ac0725bbe2c0"></a><!-- doxytag: member="Gdk::Window::pointer_ungrab" ref="c8586f7f64a088277347ac0725bbe2c0" args="(guint32 timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gdk::Window::pointer_ungrab           </td>
          <td>(</td>
          <td class="paramtype">guint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ungrabs the pointer on the default display, if it is grabbed by this application. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>A timestamp from a <a class="el" href="classGdk_1_1Event.html">Gdk::Event</a>, or Gdk::CURRENT_TIME if no timestamp is available. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3fc76fbdf9948b92dacfd1a9e340184b"></a><!-- doxytag: member="Gdk::Window::process_all_updates" ref="3fc76fbdf9948b92dacfd1a9e340184b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gdk::Window::process_all_updates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls gdk_window_process_updates() for all windows (see <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>) in the application. 
<p>

</div>
</div><p>
<a class="anchor" name="6ec5f7e788470159672511c964771285"></a><!-- doxytag: member="Gdk::Window::process_updates" ref="6ec5f7e788470159672511c964771285" args="(bool update_children)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::process_updates           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>update_children</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends one or more expose events to <em>window</em>. 
<p>
The areas in each expose event will cover the entire update area for the window (see gdk_window_invalidate_region() for details). Normally GDK calls gdk_window_process_all_updates() on your behalf, so there's no need to call this function unless you want to force expose events to be delivered immediately and synchronously (vs. the usual case, where GDK delivers them in an idle handler). Occasionally this is useful to produce nicer scrolling behavior, for example. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>update_children</em>&nbsp;</td><td>Whether to also process updates for child windows. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6eef65b862344ad01b01e527f2c39741"></a><!-- doxytag: member="Gdk::Window::raise" ref="6eef65b862344ad01b01e527f2c39741" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::raise           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raises <em>window</em> to the top of the Z-order (stacking order), so that other windows with the same parent window appear below <em>window</em>. 
<p>
This is true whether or not the windows are visible.<p>
If <em>window</em> is a toplevel, the window manager may choose to deny the request to move the window in the Z-order, gdk_window_raise() only requests the restack, does not guarantee it. 
</div>
</div><p>
<a class="anchor" name="53a80a911aab9875900da568c57b0cee"></a><!-- doxytag: member="Gdk::Window::register_dnd" ref="53a80a911aab9875900da568c57b0cee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::register_dnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a0b04aed6d338ce78f10060b025ceb3f"></a><!-- doxytag: member="Gdk::Window::remove_filter" ref="a0b04aed6d338ce78f10060b025ceb3f" args="(GdkFilterFunc function, gpointer data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::remove_filter           </td>
          <td>(</td>
          <td class="paramtype">GdkFilterFunc&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a filter previously added with gdk_window_add_filter(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>Previously-added filter function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>User data for previously-added filter function. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1de4d3f12a7f2e7e866f1d9909a9a001"></a><!-- doxytag: member="Gdk::Window::reparent" ref="1de4d3f12a7f2e7e866f1d9909a9a001" args="(const Glib::RefPtr&lt; Window &gt; &amp;new_parent, int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::reparent           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>new_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reparents <em>window</em> into the given <em>new_parent</em>. 
<p>
The window being reparented will be unmapped as a side effect. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_parent</em>&nbsp;</td><td>New parent to move <em>window</em> into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X location inside the new parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y location inside the new parent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c24547040d1662585c8ee64fe56780f6"></a><!-- doxytag: member="Gdk::Window::resize" ref="c24547040d1662585c8ee64fe56780f6" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes <em>window</em>; for toplevel windows, asks the window manager to resize the window. 
<p>
The window manager may not allow the resize. When using GTK+, use gtk_window_resize() instead of this low-level GDK function.<p>
Windows may not be resized below 1x1.<p>
If you're also planning to move the window, use gdk_window_move_resize() to both move and resize simultaneously, for a nicer visual effect. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>New width of the window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>New height of the window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7c96ca3674bbf8dbd71602d2f7893b8e"></a><!-- doxytag: member="Gdk::Window::scroll" ref="7c96ca3674bbf8dbd71602d2f7893b8e" args="(int dx, int dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::scroll           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scroll the contents of <em>window</em>, both pixels and children, by the given amount. 
<p>
<em>window</em> itself does not move. Portions of the window that the scroll operation brings in from offscreen areas are invalidated. The invalidated region may be bigger than what would strictly be necessary. (For X11, a minimum area will be invalidated if the window has no subwindows, or if the edges of the window's parent do not extend beyond the edges of the window. In other cases, a multi-step process is used to scroll the window which may produce temporary visual artifacts and unnecessary invalidations.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>Amount to scroll in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>Amount to scroll in the Y direction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cb1d7d6cbd6691a38b699a39d2eecc30"></a><!-- doxytag: member="Gdk::Window::set_accept_focus" ref="cb1d7d6cbd6691a38b699a39d2eecc30" args="(bool accept_focus=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_accept_focus           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>accept_focus</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting <em>accept_focus</em> to <code>false</code> hints the desktop environment that the window doesn't want to receive input focus. 
<p>
On X, it is the responsibility of the window manager to interpret this hint. ICCCM-compliant window manager usually respect it.<p>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000013">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>accept_focus</em>&nbsp;</td><td><code>true</code> if the window should receive input focus. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="27f458f963e431f559b0b64c3134e40c"></a><!-- doxytag: member="Gdk::Window::set_back_pixmap" ref="27f458f963e431f559b0b64c3134e40c" args="(const Glib::RefPtr&lt; Pixmap &gt; &amp;pixmap, bool parent_relative=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_back_pixmap           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixmap.html">Pixmap</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>pixmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>parent_relative</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the background pixmap of <em>window</em>. 
<p>
A background pixmap will be tiled, positioning the first tile at the origin of <em>window</em>, or if <em>parent_relative</em> is <code>true</code>, the tiling will be done based on the origin of the parent window (useful to align tiles in a parent with tiles in a child).<p>
The windowing system will normally fill a window with its background when the window is obscured then exposed, and when you call gdk_window_clear().<p>
See also <a class="el" href="classGdk_1_1Window.html#729b9a7dfc3d4da8bfb0761d78b626d4" title="Unsets the background pixmap of window so that the window will have no background...">unset_back_pixmap()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixmap</em>&nbsp;</td><td>A <a class="el" href="classGdk_1_1Pixmap.html" title="Pixmaps are offscreen drawables.">Gdk::Pixmap</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent_relative</em>&nbsp;</td><td>Whether the tiling origin is at the origin of <em>window's</em> parent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3beabdcf6f6f2c36f03288aaba209863"></a><!-- doxytag: member="Gdk::Window::set_background" ref="3beabdcf6f6f2c36f03288aaba209863" args="(const Color &amp;color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_background           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Color.html">Color</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the background color of <em>window</em>. 
<p>
(However, when using GTK+, set the background of a widget with gtk_widget_modify_bg() - if you're an application - or gtk_style_set_background() - if you're implementing a custom widget.)<p>
The <em>color</em> must be allocated; gdk_rgb_find_color() is the best way to allocate a color.<p>
See also gdk_window_set_back_pixmap(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>An allocated <a class="el" href="classGdk_1_1Color.html" title="Gdk::Color is used to describe an allocated or unallocated color.">Gdk::Color</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4c4a3eff84349ff97ecf1d24972cc751"></a><!-- doxytag: member="Gdk::Window::set_child_input_shapes" ref="4c4a3eff84349ff97ecf1d24972cc751" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_child_input_shapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the input shape mask of <em>window</em> to the union of input shape masks for all children of <em>window</em>, ignoring the input shape mask of <em>window</em> itself. 
<p>
Contrast with gdk_window_merge_child_input_shapes() which includes the input shape mask of <em>window</em> in the masks to be merged.<p>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000019">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="0573c6c2876784956e463eccebb55c6f"></a><!-- doxytag: member="Gdk::Window::set_child_shapes" ref="0573c6c2876784956e463eccebb55c6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_child_shapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the shape mask of <em>window</em> to the union of shape masks for all children of <em>window</em>, ignoring the shape mask of <em>window</em> itself. 
<p>
Contrast with gdk_window_merge_child_shapes() which includes the shape mask of <em>window</em> in the masks to be merged. 
</div>
</div><p>
<a class="anchor" name="ba9d5bea3de05b31eff0da2bed753db8"></a><!-- doxytag: member="Gdk::Window::set_composited" ref="ba9d5bea3de05b31eff0da2bed753db8" args="(bool composited=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_composited           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>composited</em> = <code>TRUE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> as composited, or unsets it. 
<p>
Composited windows do not automatically have their contents drawn to the screen. Drawing is redirected to an offscreen buffer and an expose event is emitted on the parent of the composited window. It is the responsibility of the parent's expose handler to manually merge the off-screen content onto the screen in whatever way it sees fit. See &lt;xref linkend="composited-window-example"/&gt; for an example.<p>
It only makes sense for child windows to be composited; see gdk_window_set_opacity() if you need translucent toplevel windows.<p>
An additional effect of this call is that the area of this window is no longer clipped from regions marked for invalidation on its parent. Draws done on the parent window are also no longer clipped by the child.<p>
This call is only supported on some systems (currently, only X11 with new enough Xcomposite and Xdamage extensions). You must call <a class="el" href="classGdk_1_1Display.html#eb030dde7590e1b649f398e99da0c9b3" title="Returns: true if windows may be composited.">Gdk::Display::supports_composite()</a> to check if setting a window as composited is supported before attempting to do so.<p>
<dl compact><dt><b><a class="el" href="newin2p12s.html#_newin2p12s000013">Since gtkmm 2.12:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>composited</em>&nbsp;</td><td><code>true</code> to set the window as composited. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba9323e496965a473e37566140cc9a10"></a><!-- doxytag: member="Gdk::Window::set_cursor" ref="ba9323e496965a473e37566140cc9a10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_cursor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use the parent window's cursor. 
<p>
For top-level windows this means that it will use the default cursor for the ROOT window. 
</div>
</div><p>
<a class="anchor" name="bb73b1f599ce6cb72d2e184c63610fd0"></a><!-- doxytag: member="Gdk::Window::set_cursor" ref="bb73b1f599ce6cb72d2e184c63610fd0" args="(const Cursor &amp;cursor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_cursor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Cursor.html">Cursor</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mouse pointer for a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>. 
<p>
To make the cursor invisible, use gdk_cursor_new_from_pixmap() to create a cursor with no pixels in it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td>A cursor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="736baef4396a9255cc820ba60245769a"></a><!-- doxytag: member="Gdk::Window::set_debug_updates" ref="736baef4396a9255cc820ba60245769a" args="(bool setting=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gdk::Window::set_debug_updates           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
With update debugging enabled, calls to gdk_window_invalidate_region() clear the invalidated region of the screen to a noticeable color, and GDK pauses for a short time before sending exposes to windows during gdk_window_process_updates(). 
<p>
The net effect is that you can see the invalid region for each window and watch redraws as they occur. This allows you to diagnose inefficiencies in your application.<p>
In essence, because the GDK rendering model prevents all flicker, if you are redrawing the same region 400 times you may never notice, aside from noticing a speed problem. Enabling update debugging causes GTK to flicker slowly and noticeably, so you can see exactly what's being redrawn when, in what order.<p>
The --gtk-debug=updates command line option passed to GTK+ programs enables this debug option at application startup time. That's usually more useful than calling gdk_window_set_debug_updates() yourself, though you might want to use this function to enable updates sometime after application startup time. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td><code>true</code> to turn on update debugging. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="851f5cf4a7e203d8f6f6078818b7f80d"></a><!-- doxytag: member="Gdk::Window::set_decorations" ref="851f5cf4a7e203d8f6f6078818b7f80d" args="(WMDecoration decorations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_decorations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g1164863f498802821810010d1f3202a4">WMDecoration</a>&nbsp;</td>
          <td class="paramname"> <em>decorations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
"Decorations" are the features the window manager adds to a toplevel <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>. 
<p>
This function sets the traditional Motif window manager hints that tell the window manager which decorations you would like your window to have. Usually you should use gtk_window_set_decorated() on a <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a> instead of using the GDK function directly.<p>
The <em>decorations</em> argument is the logical OR of the fields in the <a class="el" href="group__gdkmmEnums.html#g1164863f498802821810010d1f3202a4">Gdk::WMDecoration</a> enumeration. If <a class="el" href="group__gdkmmEnums.html#gg1164863f498802821810010d1f3202a43a643ce1ccc411ac59f2d69df8632a9e">Gdk::DECOR_ALL</a> is included in the mask, the other bits indicate which decorations should be turned off. If <a class="el" href="group__gdkmmEnums.html#gg1164863f498802821810010d1f3202a43a643ce1ccc411ac59f2d69df8632a9e">Gdk::DECOR_ALL</a> is not included, then the other bits indicate which decorations should be turned on.<p>
Most window managers honor a decorations hint of 0 to disable all decorations, but very few honor all possible combinations of bits. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>decorations</em>&nbsp;</td><td>Decoration hint mask. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="be022e72429562865fa0d31587056890"></a><!-- doxytag: member="Gdk::Window::set_events" ref="be022e72429562865fa0d31587056890" args="(EventMask event_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_events           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">EventMask</a>&nbsp;</td>
          <td class="paramname"> <em>event_mask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The event mask for a window determines which events will be reported for that window. 
<p>
For example, an event mask including <a class="el" href="group__gdkmmEnums.html#gg0288c23e93ded8c0326235f1f1120c61c6ca9cdcce9b0040e466906754fe8c3a">Gdk::BUTTON_PRESS_MASK</a> means the window should report button press events. The event mask is the bitwise OR of values from the <a class="el" href="group__gdkmmEnums.html#g0288c23e93ded8c0326235f1f1120c61">Gdk::EventMask</a> enumeration. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event_mask</em>&nbsp;</td><td><a class="el" href="classGdk_1_1Event.html">Event</a> mask for <em>window</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="df1d9237560226bc8b78ae48c9172e08"></a><!-- doxytag: member="Gdk::Window::set_focus_on_map" ref="df1d9237560226bc8b78ae48c9172e08" args="(bool focus_on_map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_focus_on_map           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>focus_on_map</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting <em>focus_on_map</em> to <code>false</code> hints the desktop environment that the window doesn't want to receive input focus when it is mapped. 
<p>
focus_on_map should be turned off for windows that aren't triggered interactively (such as popups from network activity).<p>
On X, it is the responsibility of the window manager to interpret this hint. Window managers following the freedesktop.org window manager extension specification should respect it.<p>
<dl compact><dt><b><a class="el" href="newin2p6s.html#_newin2p6s000014">Since gtkmm 2.6:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>focus_on_map</em>&nbsp;</td><td><code>true</code> if the window should receive input focus when mapped. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2ada3527bed8ba03670d83203c09a446"></a><!-- doxytag: member="Gdk::Window::set_functions" ref="2ada3527bed8ba03670d83203c09a446" args="(WMFunction functions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_functions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#ge86c2fc4eac7ecb9c6c9dd841b1ba6af">WMFunction</a>&nbsp;</td>
          <td class="paramname"> <em>functions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets hints about the window management functions to make available via buttons on the window frame. 
<p>
On the X backend, this function sets the traditional Motif window manager hint for this purpose. However, few window managers do anything reliable or interesting with this hint. Many ignore it entirely.<p>
The <em>functions</em> argument is the logical OR of values from the <a class="el" href="group__gdkmmEnums.html#ge86c2fc4eac7ecb9c6c9dd841b1ba6af">Gdk::WMFunction</a> enumeration. If the bitmask includes <a class="el" href="group__gdkmmEnums.html#gge86c2fc4eac7ecb9c6c9dd841b1ba6afaf77825342f052d79c9677d30fb746a6">Gdk::FUNC_ALL</a>, then the other bits indicate which functions to disable; if it doesn't include <a class="el" href="group__gdkmmEnums.html#gge86c2fc4eac7ecb9c6c9dd841b1ba6afaf77825342f052d79c9677d30fb746a6">Gdk::FUNC_ALL</a>, it indicates which functions to enable. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functions</em>&nbsp;</td><td>Bitmask of operations to allow on <em>window</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6ec3d94409fddef481e3e57714c577fa"></a><!-- doxytag: member="Gdk::Window::set_geometry_hints" ref="6ec3d94409fddef481e3e57714c577fa" args="(const Geometry &amp;geometry, WindowHints geom_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_geometry_hints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGdk.html#f6948e754cab4e79c6430fb94e438d83">Geometry</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g7dd31e80216f3452a1e080bd22fcfd9c">WindowHints</a>&nbsp;</td>
          <td class="paramname"> <em>geom_mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the geometry hints for <em>window</em>. 
<p>
Hints flagged in <em>geom_mask</em> are set, hints not flagged in <em>geom_mask</em> are unset. To unset all hints, use a <em>geom_mask</em> of 0 and a <em>geometry</em> of <code>0</code>.<p>
This function provides hints to the windowing system about acceptable sizes for a toplevel window. The purpose of this is to constrain user resizing, but the windowing system will typically (but is not required to) also constrain the current size of the window to the provided values and constrain programatic resizing via gdk_window_resize() or gdk_window_move_resize().<p>
Note that on X11, this effect has no effect on windows of type <a class="el" href="group__gdkmmEnums.html#gg2b9f4daf18d16a75d9bfe279f5340c029cc2982173a3d9859835344f5cd99c16">Gdk::WINDOW_TEMP</a> or windows where override redirect has been turned on via gdk_window_set_override_redirect() since these windows are not resizable by the user.<p>
Since you can't count on the windowing system doing the constraints for programmatic resizes, you should generally call gdk_window_constrain_size() yourself to determine appropriate sizes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry hints. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geom_mask</em>&nbsp;</td><td>Bitmask indicating fields of <em>geometry</em> to pay attention to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c45fc54f035a56f9b8c6a1f5a8a63ed3"></a><!-- doxytag: member="Gdk::Window::set_group" ref="c45fc54f035a56f9b8c6a1f5a8a63ed3" args="(const Glib::RefPtr&lt; Window &gt; &amp;leader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_group           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>leader</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the group leader window for <em>window</em>. 
<p>
By default, GDK sets the group leader for all toplevel windows to a global window implicitly created by GDK. With this function you can override this default.<p>
The group leader window allows the window manager to distinguish all windows that belong to a single application. It may for example allow users to minimize/unminimize all windows belonging to an application at once. You should only set a non-default group window if your application pretends to be multiple applications. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leader</em>&nbsp;</td><td>Group leader window, or <code>0</code> to restore the default group leader window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8eba9690001e09932eccc46c08aff05c"></a><!-- doxytag: member="Gdk::Window::set_icon" ref="8eba9690001e09932eccc46c08aff05c" args="(const Glib::RefPtr&lt; Window &gt; &amp;icon_window, const Glib::RefPtr&lt; Pixmap &gt; &amp;pixmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_icon           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>icon_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixmap.html">Pixmap</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>pixmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0f9e1a266aec25fb998accc03c90d6c4"></a><!-- doxytag: member="Gdk::Window::set_icon" ref="0f9e1a266aec25fb998accc03c90d6c4" args="(const Glib::RefPtr&lt; Window &gt; &amp;icon_window, const Glib::RefPtr&lt; Pixmap &gt; &amp;pixmap, const Glib::RefPtr&lt; Bitmap &gt; &amp;mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_icon           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>icon_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixmap.html">Pixmap</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>pixmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Bitmap.html">Bitmap</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the icon of <em>window</em> as a pixmap or window. 
<p>
If using GTK+, investigate gtk_window_set_default_icon_list() first, and then gtk_window_set_icon_list() and gtk_window_set_icon(). If those don't meet your needs, look at gdk_window_set_icon_list(). Only if all those are too high-level do you want to fall back to gdk_window_set_icon(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icon_window</em>&nbsp;</td><td>A <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> to use for the icon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixmap</em>&nbsp;</td><td>A <a class="el" href="classGdk_1_1Pixmap.html" title="Pixmaps are offscreen drawables.">Gdk::Pixmap</a> to use as the icon,. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>A 1-bit pixmap (<a class="el" href="classGdk_1_1Bitmap.html" title="Bitmaps are simply pixmaps with a depth of 1.">Gdk::Bitmap</a>) to use as mask for <em>pixmap</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="afd2706d1abf1f2ed0de4cbb3708d7cb"></a><!-- doxytag: member="Gdk::Window::set_icon_list" ref="afd2706d1abf1f2ed0de4cbb3708d7cb" args="(const Glib::ListHandle&lt; Glib::RefPtr&lt; Gdk::Pixbuf &gt; &gt; &amp;pixbufs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_icon_list           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ListHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>pixbufs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a list of icons for the window. 
<p>
One of these will be used to represent the window when it has been iconified. The icon is usually shown in an icon box or some sort of task bar. Which icon size is shown depends on the window manager. The window manager can scale the icon but setting several size icons can give better image quality since the window manager may only need to scale the icon by a small amount or not at all. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixbufs</em>&nbsp;</td><td>A list of pixbufs, of different sizes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5e3fbd4f07bed0a5060b32a07a127b6"></a><!-- doxytag: member="Gdk::Window::set_icon_name" ref="c5e3fbd4f07bed0a5060b32a07a127b6" args="(const Glib::ustring &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_icon_name           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Windows may have a name used while minimized, distinct from the name they display in their titlebar. 
<p>
Most of the time this is a bad idea from a user interface standpoint. But you can set such a name with this function, if you like. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of window while iconified (minimized). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2e961a8cba7b796e7787ab1857340ded"></a><!-- doxytag: member="Gdk::Window::set_keep_above" ref="2e961a8cba7b796e7787ab1857340ded" args="(bool setting=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_keep_above           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set if <em>window</em> must be kept above other windows. 
<p>
If the window was already above, then this function does nothing.<p>
On X11, asks the window manager to keep <em>window</em> above, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "keep above"; so you can't rely on the window being kept above. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.<p>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000011">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Whether to keep <em>window</em> above other windows. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1e740ff027fc23170a1fd3cd12cbd3d0"></a><!-- doxytag: member="Gdk::Window::set_keep_below" ref="1e740ff027fc23170a1fd3cd12cbd3d0" args="(bool setting=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_keep_below           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set if <em>window</em> must be kept below other windows. 
<p>
If the window was already below, then this function does nothing.<p>
On X11, asks the window manager to keep <em>window</em> below, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "keep below"; so you can't rely on the window being kept below. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.<p>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000012">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Whether to keep <em>window</em> below other windows. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="22dc81b0749d30bbbdf5906059459482"></a><!-- doxytag: member="Gdk::Window::set_modal_hint" ref="22dc81b0749d30bbbdf5906059459482" args="(bool modal=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_modal_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>modal</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The application can use this hint to tell the window manager that a certain window has modal behaviour. 
<p>
The window manager can use this information to handle modal windows in a special way.<p>
You should only use this on windows for which you have previously called gdk_window_set_transient_for() <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>modal</em>&nbsp;</td><td><code>true</code> if the window is modal, <code>false</code> otherwise. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f70da6bc12c5997b6cd77f4cd14e5129"></a><!-- doxytag: member="Gdk::Window::set_opacity" ref="f70da6bc12c5997b6cd77f4cd14e5129" args="(double opacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_opacity           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>opacity</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request the windowing system to make <em>window</em> partially transparent, with opacity 0 being fully transparent and 1 fully opaque. 
<p>
(Values of the opacity parameter are clamped to the [0,1] range.)<p>
On X11, this works only on X screens with a compositing manager running.<p>
For setting up per-pixel alpha, see <a class="el" href="classGdk_1_1Screen.html#a6af99bfe6ad813e1c5f8ee9a933e2e0" title="Gets a colormap to use for creating windows or pixmaps with an alpha channel.">Gdk::Screen::get_rgba_colormap()</a>. For making non-toplevel windows translucent, see gdk_window_set_composited().<p>
<dl compact><dt><b><a class="el" href="newin2p12s.html#_newin2p12s000016">Since gtkmm 2.12:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opacity</em>&nbsp;</td><td>Opacity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ad09335b20323d81cb214e549ba201e6"></a><!-- doxytag: member="Gdk::Window::set_override_redirect" ref="ad09335b20323d81cb214e549ba201e6" args="(bool override_redirect=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_override_redirect           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>override_redirect</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An override redirect window is not under the control of the window manager. 
<p>
This means it won't have a titlebar, won't be minimizable, etc. - it will be entirely under the control of the application. The window manager can't see the override redirect window at all.<p>
Override redirect should only be used for short-lived temporary windows, such as popup menus. <a class="el" href="classGtk_1_1Menu.html" title="A drop-down menu consisting of Gtk::MenuItem objects which can be navigated and activated...">Gtk::Menu</a> uses an override redirect window in its implementation, for example. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>override_redirect</em>&nbsp;</td><td><code>true</code> if window should be override redirect. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f0af1130cfb882913b80d9a82123479e"></a><!-- doxytag: member="Gdk::Window::set_role" ref="f0af1130cfb882913b80d9a82123479e" args="(const Glib::ustring &amp;role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_role           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>role</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When using GTK+, typically you should use gtk_window_set_role() instead of this low-level function. 
<p>
The window manager and session manager use a window's role to distinguish it from other kinds of window in the same application. When an application is restarted after being saved in a previous session, all windows with the same title and role are treated as interchangeable. So if you have two windows with the same title that should be distinguished for session management purposes, you should set the role on those windows. It doesn't matter what string you use for the role, as long as you have a different role for each non-interchangeable kind of window. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>role</em>&nbsp;</td><td>A string indicating its role. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a4900976eda16fc8a6280eb0bd325f8c"></a><!-- doxytag: member="Gdk::Window::set_skip_pager_hint" ref="a4900976eda16fc8a6280eb0bd325f8c" args="(bool skips_pager=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_skip_pager_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>skips_pager</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles whether a window should appear in a pager (workspace switcher, or other desktop utility program that displays a small thumbnail representation of the windows on the desktop). 
<p>
If a window's semantic type as specified with gdk_window_set_type_hint() already fully describes the window, this function should <em>not</em> be called in addition, instead you should allow the window to be treated according to standard policy for its semantic type.<p>
<dl compact><dt><b><a class="el" href="newin2p2s.html#_newin2p2s000090">Since gtkmm 2.2:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>skips_pager</em>&nbsp;</td><td><code>true</code> to skip the pager. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="34b9d99e30afd4e4106d66408d007fdd"></a><!-- doxytag: member="Gdk::Window::set_skip_taskbar_hint" ref="34b9d99e30afd4e4106d66408d007fdd" args="(bool skips_taskbar=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_skip_taskbar_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>skips_taskbar</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles whether a window should appear in a task list or window list. 
<p>
If a window's semantic type as specified with gdk_window_set_type_hint() already fully describes the window, this function should <em>not</em> be called in addition, instead you should allow the window to be treated according to standard policy for its semantic type.<p>
<dl compact><dt><b><a class="el" href="newin2p2s.html#_newin2p2s000089">Since gtkmm 2.2:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>skips_taskbar</em>&nbsp;</td><td><code>true</code> to skip the taskbar. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c7958efa9bf3499bf411bff07edc39d"></a><!-- doxytag: member="Gdk::Window::set_sm_client_id" ref="5c7958efa9bf3499bf411bff07edc39d" args="(const Glib::ustring &amp;sm_client_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gdk::Window::set_sm_client_id           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>sm_client_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <code>SM_CLIENT_ID</code> property on the application's leader window so that the window manager can save the application's state using the X11R6 ICCCM session management protocol. 
<p>
See the X Session Management Library documentation for more information on session management and the Inter-Client Communication Conventions Manual (ICCCM) for information on the <code>WM_CLIENT_LEADER</code> property. (Both documents are part of the X&nbsp;Window System distribution.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm_client_id</em>&nbsp;</td><td>The client id assigned by the session manager when the connection was opened. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="246b2c39068bf02f4e981fde58f8d776"></a><!-- doxytag: member="Gdk::Window::set_startup_id" ref="246b2c39068bf02f4e981fde58f8d776" args="(const Glib::ustring &amp;startup_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_startup_id           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>startup_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When using GTK+, typically you should use gtk_window_set_startup_id() instead of this low-level function. 
<p>
<dl compact><dt><b><a class="el" href="newin2p12s.html#_newin2p12s000014">Since gtkmm 2.12:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startup_id</em>&nbsp;</td><td>A string with startup-notification identifier. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7886467cef616c0c07ba482888490059"></a><!-- doxytag: member="Gdk::Window::set_static_gravities" ref="7886467cef616c0c07ba482888490059" args="(bool use_static=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gdk::Window::set_static_gravities           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_static</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the bit gravity of the given window to static, and flag it so all children get static subwindow gravity. 
<p>
This is used if you are implementing scary features that involve deep knowledge of the windowing system. Don't worry about it unless you have to. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>use_static</em>&nbsp;</td><td><code>true</code> to turn on static gravity. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the server supports static gravity. </dd></dl>

</div>
</div><p>
<a class="anchor" name="89c47b105ce213eb1b075d1c8dd34ab6"></a><!-- doxytag: member="Gdk::Window::set_title" ref="89c47b105ce213eb1b075d1c8dd34ab6" args="(const Glib::ustring &amp;title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_title           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>title</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the title of a toplevel window, to be displayed in the titlebar. 
<p>
If you haven't explicitly set the icon name for the window (using gdk_window_set_icon_name()), the icon name will be set to <em>title</em> as well. <em>title</em> must be in UTF-8 encoding (as with all user-readable strings in GDK/GTK+). <em>title</em> may not be <code>0</code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>title</em>&nbsp;</td><td>Title of <em>window</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b8e6f4a6758057f249a41eccb3c59061"></a><!-- doxytag: member="Gdk::Window::set_transient_for" ref="b8e6f4a6758057f249a41eccb3c59061" args="(const Glib::RefPtr&lt; Window &gt; &amp;parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_transient_for           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Window</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates to the window manager that <em>window</em> is a transient dialog associated with the application window <em>parent</em>. 
<p>
This allows the window manager to do things like center <em>window</em> on <em>parent</em> and keep <em>window</em> above <em>parent</em>.<p>
See gtk_window_set_transient_for() if you're using <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a> or <a class="el" href="classGtk_1_1Dialog.html" title="Create popup windows.">Gtk::Dialog</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Another toplevel <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4505331d1882e0e02d076782ddfaa2ff"></a><!-- doxytag: member="Gdk::Window::set_type_hint" ref="4505331d1882e0e02d076782ddfaa2ff" args="(WindowTypeHint hint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_type_hint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gdkmmEnums.html#g1f75a8db0f289997ac16bba0891776c9">WindowTypeHint</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The application can use this call to provide a hint to the window manager about the functionality of a window. 
<p>
The window manager can use this information when determining the decoration and behaviour of the window.<p>
The hint must be set before the window is mapped. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hint</em>&nbsp;</td><td>A hint of the function this window will have. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9f22c1db8469dbe6fa8229e80d344434"></a><!-- doxytag: member="Gdk::Window::set_urgency_hint" ref="9f22c1db8469dbe6fa8229e80d344434" args="(bool urgent=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_urgency_hint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>urgent</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles whether a window needs the user's urgent attention. 
<p>
<dl compact><dt><b><a class="el" href="newin2p8s.html#_newin2p8s000009">Since gtkmm 2.8:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>urgent</em>&nbsp;</td><td><code>true</code> if the window is urgent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6e895c78858224262b90564b68759b62"></a><!-- doxytag: member="Gdk::Window::set_user_data" ref="6e895c78858224262b90564b68759b62" args="(gpointer user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::set_user_data           </td>
          <td>(</td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>user_data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For most purposes this function is deprecated in favor of Glib::object_set_data(). 
<p>
However, for historical reasons GTK+ stores the <a class="el" href="classGtk_1_1Widget.html" title="Abstract Widget (Base class for all widgets).">Gtk::Widget</a> that owns a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> as user data on the <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>. So, custom widget implementations should use this function for that. If GTK+ receives an event for a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a>, and the user data for the window is non-<code>0</code>, GTK+ will assume the user data is a <a class="el" href="classGtk_1_1Widget.html" title="Abstract Widget (Base class for all widgets).">Gtk::Widget</a>, and forward the event to that widget. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7e7ccbbb8a86215d0478b9fc041dce34"></a><!-- doxytag: member="Gdk::Window::shape_combine_mask" ref="7e7ccbbb8a86215d0478b9fc041dce34" args="(const Glib::RefPtr&lt; Bitmap &gt; &amp;mask, int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::shape_combine_mask           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Bitmap.html">Bitmap</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a shape mask to <em>window</em>. 
<p>
Pixels in <em>window</em> corresponding to set bits in the <em>mask</em> will be visible; pixels in <em>window</em> corresponding to unset bits in the <em>mask</em> will be transparent. This gives a non-rectangular window.<p>
If <em>mask</em> is <code>0</code>, the shape mask will be unset, and the <em>x/</em> <em>y</em> parameters are not used.<p>
On the X11 platform, this uses an X server extension which is widely available on most common platforms, but not available on very old X servers, and occasionally the implementation will be buggy. On servers without the shape extension, this function will do nothing.<p>
On the Win32 platform the functionality is always present.<p>
This function works on both toplevel and child windows. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Shape mask. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X position of shape mask with respect to <em>window</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y position of shape mask with respect to <em>window</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4ddecf82c0b07e4ad106caf90f17ca8f"></a><!-- doxytag: member="Gdk::Window::shape_combine_region" ref="4ddecf82c0b07e4ad106caf90f17ca8f" args="(const Region &amp;shape_region, int offset_x, int offset_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::shape_combine_region           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGdk_1_1Region.html">Region</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>shape_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes pixels in <em>window</em> outside <em>shape_region</em> be transparent, so that the window may be nonrectangular. 
<p>
See also gdk_window_shape_combine_mask() to use a bitmap as the mask.<p>
If <em>shape_region</em> is <code>0</code>, the shape will be unset, so the whole window will be opaque again. <em>offset_x</em> and <em>offset_y</em> are ignored if <em>shape_region</em> is <code>0</code>.<p>
On the X11 platform, this uses an X server extension which is widely available on most common platforms, but not available on very old X servers, and occasionally the implementation will be buggy. On servers without the shape extension, this function will do nothing.<p>
On the Win32 platform, this functionality is always present.<p>
This function works on both toplevel and child windows. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shape_region</em>&nbsp;</td><td><a class="el" href="classGdk_1_1Region.html" title="This is an opaque data type holding a set of arbitrary pixels, and is usually used...">Region</a> of window to be non-transparent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_x</em>&nbsp;</td><td>X position of <em>shape_region</em> in <em>window</em> coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset_y</em>&nbsp;</td><td>Y position of <em>shape_region</em> in <em>window</em> coordinates. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d850f17e45522107fb498de8641766f7"></a><!-- doxytag: member="Gdk::Window::show" ref="d850f17e45522107fb498de8641766f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::show           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like gdk_window_show_unraised(), but also raises the window to the top of the window stack (moves the window to the front of the Z-order). 
<p>
This function maps a window so it's visible onscreen. Its opposite is gdk_window_hide().<p>
When implementing a <a class="el" href="classGtk_1_1Widget.html" title="Abstract Widget (Base class for all widgets).">Gtk::Widget</a>, you should call this function on the widget's <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> as part of the "map" method. 
</div>
</div><p>
<a class="anchor" name="2c6d829cf3fc060ab52a4bdc7d77973a"></a><!-- doxytag: member="Gdk::Window::show_unraised" ref="2c6d829cf3fc060ab52a4bdc7d77973a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::show_unraised           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shows a <a class="el" href="classGdk_1_1Window.html" title="A Gdk::Window is a rectangular region on the screen.">Gdk::Window</a> onscreen, but does not modify its stacking order. 
<p>
In contrast, gdk_window_show() will raise the window to the top of the window stack.<p>
On the X11 platform, in Xlib terms, this function calls XMapWindow() (it also updates some internal GDK state, which means that you can't really use XMapWindow() directly on a GDK window). 
</div>
</div><p>
<a class="anchor" name="72cddee1b5ed8a663b6f245e59132473"></a><!-- doxytag: member="Gdk::Window::stick" ref="72cddee1b5ed8a663b6f245e59132473" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::stick           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
"Pins" a window such that it's on all workspaces and does not scroll with viewports, for window managers that have scrollable viewports. 
<p>
(When using <a class="el" href="classGtk_1_1Window.html" title="Toplevel Window This represents all widgets which are physical windows controlled...">Gtk::Window</a>, gtk_window_stick() may be more useful.)<p>
On the X11 platform, this function depends on window manager support, so may have no effect with many window managers. However, GDK will do the best it can to convince the window manager to stick the window. For window managers that don't support this operation, there's nothing you can do to force it to happen. 
</div>
</div><p>
<a class="anchor" name="128616c32cb210b0181a74d6f6bfa4a5"></a><!-- doxytag: member="Gdk::Window::thaw_updates" ref="128616c32cb210b0181a74d6f6bfa4a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::thaw_updates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thaws a window frozen with <a class="el" href="classGdk_1_1Window.html#15ebab2c454f75f0a5342542626cbdde" title="Temporarily freezes a window such that it won&#39;t receive expose events.">Gdk::Window::freeze_updates()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="46d71da2107832855f8d047b3effbb67"></a><!-- doxytag: member="Gdk::Window::unfullscreen" ref="46d71da2107832855f8d047b3effbb67" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::unfullscreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the window out of fullscreen mode. 
<p>
If the window was not fullscreen, does nothing.<p>
On X11, asks the window manager to move <em>window</em> out of the fullscreen state, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "fullscreen"; so you can't rely on the unfullscreenification actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.<p>
<dl compact><dt><b><a class="el" href="newin2p2s.html#_newin2p2s000092">Since gtkmm 2.2:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="d9325d93af96ee6774ffa4fa354d1d25"></a><!-- doxytag: member="Gdk::Window::unmaximize" ref="d9325d93af96ee6774ffa4fa354d1d25" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::unmaximize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unmaximizes the window. 
<p>
If the window wasn't maximized, then this function does nothing.<p>
On X11, asks the window manager to unmaximize <em>window</em>, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "maximized"; so you can't rely on the unmaximization actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.<p>
On Windows, reliably unmaximizes the window. 
</div>
</div><p>
<a class="anchor" name="729b9a7dfc3d4da8bfb0761d78b626d4"></a><!-- doxytag: member="Gdk::Window::unset_back_pixmap" ref="729b9a7dfc3d4da8bfb0761d78b626d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::unset_back_pixmap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsets the background pixmap of <em>window</em> so that the window will have no background. 
<p>
A window with no background will never have its background filled by the windowing system, instead the window will contain whatever pixels were already in the corresponding area of the display.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classGdk_1_1Window.html#27f458f963e431f559b0b64c3134e40c" title="Sets the background pixmap of window.">set_back_pixmap()</a>. </dd></dl>
<dl compact><dt><b><a class="el" href="newin2p14s.html#_newin2p14s000003">Since gtkmm 2.14:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="700b396befa605d159f2cd697a1f6014"></a><!-- doxytag: member="Gdk::Window::unset_icon" ref="700b396befa605d159f2cd697a1f6014" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::unset_icon           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8f3bfc50b1db35f74e9af21fc81591a0"></a><!-- doxytag: member="Gdk::Window::unset_shape_combine_mask" ref="8f3bfc50b1db35f74e9af21fc81591a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::unset_shape_combine_mask           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b8b3893818a244b31fed8460586cd2d6"></a><!-- doxytag: member="Gdk::Window::unset_sm_client_id" ref="b8b3893818a244b31fed8460586cd2d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gdk::Window::unset_sm_client_id           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="22e499aeadc19f7373972355ae2872cb"></a><!-- doxytag: member="Gdk::Window::unstick" ref="22e499aeadc19f7373972355ae2872cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::unstick           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reverse operation for gdk_window_stick(); see gdk_window_stick(), and gtk_window_unstick(). 
<p>

</div>
</div><p>
<a class="anchor" name="a7a5705224d062fe6351a426781597fa"></a><!-- doxytag: member="Gdk::Window::withdraw" ref="a7a5705224d062fe6351a426781597fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gdk::Window::withdraw           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Withdraws a window (unmaps it and asks the window manager to forget about it). 
<p>
This function is not really useful as gdk_window_hide() automatically withdraws toplevel windows before hiding them. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="c7eeaceb12343803db90524716bf7bd0"></a><!-- doxytag: member="Gdk::Window::wrap" ref="c7eeaceb12343803db90524716bf7bd0" args="(GdkWindowObject *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Window.html">Gdk::Window</a>&gt; wrap           </td>
          <td>(</td>
          <td class="paramtype">GdkWindowObject *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A Glib::wrap() method for this object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&nbsp;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gdk_2gdkmm_2window_8h.html">gdk/gdkmm/window.h</a></ul>
</div>
</div>
<!-- end main content -->

<hr><address><small>
Generated for gtkmm 2.4 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.8 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
