<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gtkmm 2.4: Gtk::TextBuffer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/gtkmm_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="http://www.gtkmm.org/documentation.shtml">Main Page</a> &nbsp;
  <a href="group__Widgets.html">Widgets</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
  <a href="../../tutorial/html/index.html"> Book</a> &nbsp;
</center>
<hr width="100%"/>
<!-- begin main content -->
<div id="content">
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespaceGtk.html">Gtk</a>::<a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a>
  </div>
<div class="contents">
<h1>Gtk::TextBuffer Class Reference<br>
<small>
[<a class="el" href="group__TextView.html">TextView Classes</a>]</small>
</h1><!-- doxytag: class="Gtk::TextBuffer" --><!-- doxytag: inherits="Glib::Object" -->Multi-line attributed text that can be displayed by one or more <a class="el" href="classGtk_1_1TextView.html" title="Multi-line text editing widget.">Gtk::TextView</a> widgets.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for Gtk::TextBuffer:</div>
<div class="dynsection">
<p><center><img src="classGtk_1_1TextBuffer__inherit__graph.png" border="0" usemap="#Gtk_1_1TextBuffer__inherit__map" alt="Inheritance graph"></center>
<map name="Gtk_1_1TextBuffer__inherit__map">
<area shape="rect" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/classGlib_1_1Object.html" title="Glib::Object" alt="" coords="15,5,105,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classGtk_1_1TextBuffer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#cc9fefd2e8f66b2e27feb1abca37a840">ChildAnchor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classGtk_1_1TextMark.html">TextMark</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e8dd977bbf98a58d400f880ed30a946e">Mark</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e218bf327872d2a5ed6e3202db2627d2">Tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classGtk_1_1TextTagTable.html">TextTagTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#0d1ed6d2b21a7cb06d261e117a2c2672">TagTable</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#5b40599bc4daf29b2dd923deafc05e7e">add_mark</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp; mark, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; where)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the mark at position <em>where</em>.  <a href="#5b40599bc4daf29b2dd923deafc05e7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#d9cecd4c6d2360985966f32cad5688a8">add_selection_clipboard</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp; clipboard)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <em>clipboard</em> to the list of clipboards in which the selection contents of <em>buffer</em> are available.  <a href="#d9cecd4c6d2360985966f32cad5688a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19">apply_tag</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp; tag, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits the "apply-tag" signal on <em>buffer</em>.  <a href="#923292fd14bf207049ed100a3d635c19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#322dfc3ef866789e27565be5ec639f15">apply_tag_by_name</a> (const Glib::ustring&amp; name, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextTagTable.html#58f83d7b98cf4f496a88ef63e8969d6c" title="Look up a named tag.">Gtk::TextTagTable::lookup()</a> on the buffer's tag table to get a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, then calls <a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19" title="Emits the &quot;apply-tag&quot; signal on buffer.">apply_tag()</a>.  <a href="#322dfc3ef866789e27565be5ec639f15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e6cffbcb3b2d2fc2ba4f18e5518549aa">assign</a> (const char* text_begin, const char* text_end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#0df024c51b2bb46dd0288b96a5edcd7f">assign</a> (const Glib::ustring&amp; text)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#6ef8d2dcc85129cc399dca45a435ae24">backspace</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; iter, bool interactive=true, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs the appropriate action as if the user hit the delete key with the cursor at the position specified by <em>iter</em>.  <a href="#6ef8d2dcc85129cc399dca45a435ae24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#6c6fe08e46f141bffe7c2dfeb459c074">begin</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#f86f1ef86eb6a35df054287eab967902">begin_user_action</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to indicate that the buffer operations between here and a call to <a class="el" href="classGtk_1_1TextBuffer.html#c8a7810f527798781c28de39e5acd952" title="Should be paired with a call to begin_user_action().">end_user_action()</a> are part of a single user-visible operation.  <a href="#f86f1ef86eb6a35df054287eab967902"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#975778a084bdeba3600ca5fb7dbec797">copy_clipboard</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp; clipboard)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the currently-selected text to a clipboard.  <a href="#975778a084bdeba3600ca5fb7dbec797"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#2fee15dc2d1e21f624d1aa85ad75448c">create_child_anchor</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#8b823989431ff4b3f904efe07e9c374a">create_mark</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; where, bool left_gravity=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an anonymous mark.  <a href="#8b823989431ff4b3f904efe07e9c374a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#a355a0cc0a3c1d7f7f9ded9cc157feb5">create_mark</a> (const Glib::ustring&amp; mark_name, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; where, bool left_gravity=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a mark at position <em>where</em>.  <a href="#a355a0cc0a3c1d7f7f9ded9cc157feb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#d42f4e41a4cb2d5a824e2f0ffa78e973">create_tag</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an anoymous tag and adds it to the tag table for buffer.  <a href="#d42f4e41a4cb2d5a824e2f0ffa78e973"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#048bdd55d3f244e584074676ab482a2b">create_tag</a> (const Glib::ustring&amp; tag_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a tag and adds it to the tag table for buffer.  <a href="#048bdd55d3f244e584074676ab482a2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#5fc2972c6f1ff379e313e5e34299f827">cut_clipboard</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp; clipboard, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the currently-selected text to a clipboard, then deletes said text if it's editable.  <a href="#5fc2972c6f1ff379e313e5e34299f827"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#1582cb666cbe6c857f6f742557e19295">delete_mark</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt;&amp; mark)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes <em>mark</em>, so that it's no longer located anywhere in the buffer.  <a href="#1582cb666cbe6c857f6f742557e19295"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#0ebfbbe158f0b53b14123158f6633661">delete_mark_by_name</a> (const Glib::ustring&amp; name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the mark named <em>name</em>; the mark must exist.  <a href="#0ebfbbe158f0b53b14123158f6633661"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#c4ee0ba09f7d8d316e3db8b7402344a2">end</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#c8a7810f527798781c28de39e5acd952">end_user_action</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should be paired with a call to <a class="el" href="classGtk_1_1TextBuffer.html#f86f1ef86eb6a35df054287eab967902" title="Called to indicate that the buffer operations between here and a call to end_user_action()...">begin_user_action()</a>.  <a href="#c8a7810f527798781c28de39e5acd952"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#93a0c92f1f46b3efaf86fcbcf746db77">erase</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>, bool&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#b9e12682d654a53fc46ab36434047666">erase_interactive</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_end, bool default_editable=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#371236bd4146f5520bda252d1c50d309">erase_selection</a> (bool interactive=true, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the range between the "insert" and "selection_bound" marks, that is, the currently-selected text.  <a href="#371236bd4146f5520bda252d1c50d309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#a57d47ab3cf08829430d90fe446f41ee">get_bounds</a> (<a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_begin, <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#797303ae5468bda67b625d54fedec62b">get_can_create_tags</a> (const Glib::ustring&amp; format) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This functions returns the value set with deserialize_set_can_create_tags().  <a href="#797303ae5468bda67b625d54fedec62b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#da488c738d7311ea9cedacede3b3b03c">get_char_count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of characters in the buffer; note that characters and bytes are not the same, you can't e.g. expect the contents of the buffer in string form to be this many bytes long.  <a href="#da488c738d7311ea9cedacede3b3b03c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::StringArrayHandle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#5b0254f594094d50a3bfab30190009df">get_deserialize_formats</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#44414f75c6ec2f1758832e8935b169cd">get_has_selection</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether the buffer has some text currently selected.  <a href="#44414f75c6ec2f1758832e8935b169cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#4b92f14603f572f99daf0c86abd1b9ad">get_insert</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: insertion point mark.  <a href="#4b92f14603f572f99daf0c86abd1b9ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#adecf4e2baa4eb964e3952896561322f">get_iter_at_child_anchor</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&amp; anchor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current position of an anchor.  <a href="#adecf4e2baa4eb964e3952896561322f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#77ebbbdc688b1f2d16fbbd7e048efc4f">get_iter_at_line</a> (int line_number)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#6ad8b4b329a6183834812ebbdc74c8cf">get_iter_at_line_index</a> (int line_number, int byte_index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#b0b39b1914fd24c7f4a4f3c05d751d93">get_iter_at_line_offset</a> (int line_number, int char_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#331fadf0c7c6c470b709802fbc09984a">get_iter_at_mark</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt;&amp; mark)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current position of a mark.  <a href="#331fadf0c7c6c470b709802fbc09984a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e92edc6a06a9a5fae2ee99f762bb59ff">get_iter_at_offset</a> (int char_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#f69d5132c5439d356dedcbfcc7197fc3">get_line_count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the number of lines in the buffer.  <a href="#f69d5132c5439d356dedcbfcc7197fc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt; const <br class="typebreak">
<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#42f3ec0e6acacc18bd90a646847b3a7c">get_mark</a> (const Glib::ustring&amp; name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: a <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>, or <code>0</code>.  <a href="#42f3ec0e6acacc18bd90a646847b3a7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#2fcefaf023f05dd2e18ffa3de6063fd0">get_mark</a> (const Glib::ustring&amp; name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: a <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>, or <code>0</code>.  <a href="#2fcefaf023f05dd2e18ffa3de6063fd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#2170f20b9a330679596ef61863f6e101">get_modified</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether the buffer has been modified since the last call to <a class="el" href="classGtk_1_1TextBuffer.html#ca1d54bd5b4497881b11f6c313ac3112" title="Used to keep track of whether the buffer has been modified since the last time it...">set_modified()</a> set the modification flag to <code>false</code>.  <a href="#2170f20b9a330679596ef61863f6e101"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#59f49dbb4f753a1d523f68de91c4fe9d">get_selection_bound</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: selection bound mark.  <a href="#59f49dbb4f753a1d523f68de91c4fe9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#09d9a9132d21deee1c34baff9b20f8e0">get_selection_bounds</a> (<a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether the selection has nonzero length.  <a href="#09d9a9132d21deee1c34baff9b20f8e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::StringArrayHandle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#41b8005355c29cfa61455a6dd354ca6a">get_serialize_formats</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e1cbe191e2e2c739704d4e7fff366b06">get_slice</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end, bool include_hidden_chars=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: an allocated UTF-8 string.  <a href="#e1cbe191e2e2c739704d4e7fff366b06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#b07f68f1c4705bdfe7271eaeb36d65e5">get_slice</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end, bool include_hidden_chars=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: an allocated UTF-8 string.  <a href="#b07f68f1c4705bdfe7271eaeb36d65e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt; const <br class="typebreak">
<a class="el" href="classGtk_1_1TextTagTable.html">TextBuffer::TagTable</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#a242143c1cdbeb925f47704bf08b436e">get_tag_table</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classGtk_1_1TextTagTable.html" title="Typedefed as Gtk::TextBuffer::TagTable.">Gtk::TextTagTable</a> associated with this buffer.  <a href="#a242143c1cdbeb925f47704bf08b436e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGtk_1_1TextTagTable.html">TextBuffer::TagTable</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#3103df31b1a0fc808997fd9da44e4734">get_tag_table</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classGtk_1_1TextTagTable.html" title="Typedefed as Gtk::TextBuffer::TagTable.">Gtk::TextTagTable</a> associated with this buffer.  <a href="#3103df31b1a0fc808997fd9da44e4734"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#fd3c4c2a218879e74ffe2e60786adb0b">get_text</a> (bool include_hidden_chars=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all the text in the buffer.  <a href="#fd3c4c2a218879e74ffe2e60786adb0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#77434f057d68314a823ae47da426013a">get_text</a> (bool include_hidden_chars=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#5e6eb888811a3060cf6525c71bda319a">get_text</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end, bool include_hidden_chars=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: an allocated UTF-8 string.  <a href="#5e6eb888811a3060cf6525c71bda319a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e4f9e04000110dbfd1014ef05067a593">get_text</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end, bool include_hidden_chars=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: an allocated UTF-8 string.  <a href="#e4f9e04000110dbfd1014ef05067a593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const GtkTextBuffer*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#002e580ebeb7884bfdb8d5bc5d4122fa">gobj</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#002e580ebeb7884bfdb8d5bc5d4122fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GtkTextBuffer*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#9250bc4defcf6599e94a37b0d3caaa1d">gobj</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#9250bc4defcf6599e94a37b0d3caaa1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GtkTextBuffer*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#3e79c9310e23f741898f081689b07672">gobj_copy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#3e79c9310e23f741898f081689b07672"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#aad9d1eb6498a68ec43cdbdab9199679">insert</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies text, tags, and pixbufs between <em>range_begin</em> and <em>range_end</em> (the order of range_begin and range_begin doesn't matter) and inserts the copy at <em>pos</em>.  <a href="#aad9d1eb6498a68ec43cdbdab9199679"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#22492c63d1f0da2f04231d9ec4cbecc8">insert</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const char* text_begin, const char* text_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts text at position <em>pos</em>.  <a href="#22492c63d1f0da2f04231d9ec4cbecc8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce">insert</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::ustring&amp; text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts <em>text</em> at position <em>pos</em>.  <a href="#c6466a773421e4d48994b65f4a1703ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#9302a066984dd922034bf51c668ae17c">insert_at_cursor</a> (const char* text_begin, const char* text_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts text, using the current cursor position as the insertion point.  <a href="#9302a066984dd922034bf51c668ae17c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#53360179e6441863cec6117c6f396af0">insert_at_cursor</a> (const Glib::ustring&amp; text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts <em>text</em>, using the current cursor position as the insertion point.  <a href="#53360179e6441863cec6117c6f396af0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#80afdb5f6a08477a1977b88982069fdd">insert_child_anchor</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&amp; anchor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>, bool&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#ffa78900d98dd158b1f78c7977a535dd">insert_interactive</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; range_end, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as insert_range(), but does nothing if the insertion point isn't editable.  <a href="#ffa78900d98dd158b1f78c7977a535dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>, bool&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#5dd1053539bc3c7b306b26047f5c2725">insert_interactive</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const char* text_begin, const char* text_end, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, but the insertion will not occur if <em>pos</em> is at a non-editable location in the buffer.  <a href="#5dd1053539bc3c7b306b26047f5c2725"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>, bool&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#5ae3a0c42cf66591c116dbb5ab3efd5f">insert_interactive</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::ustring&amp; text, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, but the insertion will not occur if <em>iter</em> is at a non-editable location in the buffer.  <a href="#5ae3a0c42cf66591c116dbb5ab3efd5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#8c775f5341888798b1425cb6e8091060">insert_interactive_at_cursor</a> (const char* text_begin, const char* text_end, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextBuffer.html#5ae3a0c42cf66591c116dbb5ab3efd5f" title="Like insert(), but the insertion will not occur if iter is at a non-editable location...">insert_interactive()</a> at the cursor position.  <a href="#8c775f5341888798b1425cb6e8091060"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#07f6c4236a1ede7e4e5ced196b13bc76">insert_interactive_at_cursor</a> (const Glib::ustring&amp; text, bool default_editable=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextBuffer.html#5ae3a0c42cf66591c116dbb5ab3efd5f" title="Like insert(), but the insertion will not occur if iter is at a non-editable location...">insert_interactive()</a> at the cursor position.  <a href="#07f6c4236a1ede7e4e5ced196b13bc76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#8b2b44341f6fd7d423b6c3a9afa7aa36">insert_pixbuf</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&amp; pixbuf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#8b50becdec017a20a88c8279def83249">insert_with_tag</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const char* text_begin, const char* text_end, const Glib::ustring&amp; tag_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#134f2de521d6a00ebf2da802481cef3d">insert_with_tag</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::ustring&amp; text, const Glib::ustring&amp; tag_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e689b9324620f5b1daa1fac9d13c8130">insert_with_tag</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const char* text_begin, const char* text_end, const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp; tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#79771152944a1d16d5119e1314295c39">insert_with_tag</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::ustring&amp; text, const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp; tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#8bf700ece48eb05024521f4f7fa62a7e">insert_with_tags</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const char* text_begin, const char* text_end, const Glib::ArrayHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&gt;&amp; tags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts text into buffer at <em>pos</em>, applying the list of tags to the newly-inserted text.  <a href="#8bf700ece48eb05024521f4f7fa62a7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#afa889a4f2cf65344970cad54b5113b9">insert_with_tags</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::ustring&amp; text, const Glib::ArrayHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&gt;&amp; tags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts text into buffer at <em>pos</em>, applying the list of tags to the newly-inserted text.  <a href="#afa889a4f2cf65344970cad54b5113b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#3db6bb55ac970ecf5a9ff76983910202">insert_with_tags_by_name</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const char* text_begin, const char* text_end, const Glib::StringArrayHandle&amp; tag_names)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equivalent to calling <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, then <a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19" title="Emits the &quot;apply-tag&quot; signal on buffer.">apply_tag()</a> on the inserted text; This is just a convenience function.  <a href="#3db6bb55ac970ecf5a9ff76983910202"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#1bd15350e31b677150b6608eded9cfb2">insert_with_tags_by_name</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; pos, const Glib::ustring&amp; text, const Glib::StringArrayHandle&amp; tag_names)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts text into buffer at <em>pos</em>, applying the list of tags to the newly-inserted text.  <a href="#1bd15350e31b677150b6608eded9cfb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#82c1011da5758549e634729dcbc70839">move_mark</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt;&amp; mark, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; where)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>mark</em> to the new location <em>where</em>.  <a href="#82c1011da5758549e634729dcbc70839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#de83a7b96d0b4888de0f96cd3e0b7220">move_mark_by_name</a> (const Glib::ustring&amp; name, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; where)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the mark named <em>name</em> (which must exist) to location <em>where</em>.  <a href="#de83a7b96d0b4888de0f96cd3e0b7220"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#45969585013f07f44f7c82543cc4aa8d">paste_clipboard</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp; clipboard, bool default_editable=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#315769f47795001dc1a9449df4c22231">paste_clipboard</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp; clipboard, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; override_location, bool default_editable=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#1dff95f7dc9ea889a25596a87b2f8c35">place_cursor</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; where)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function moves the "insert" and "selection_bound" marks simultaneously.  <a href="#1dff95f7dc9ea889a25596a87b2f8c35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt;int&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#7f118d392de01d035844edf11cc14929">property_cursor_position</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The position of the insert mark (as offset from the beginning of the buffer).  <a href="#7f118d392de01d035844edf11cc14929"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::PropertyProxy_ReadOnly<br class="typebreak">
&lt;bool&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#4a751ec1bbd2f0eecf1aab9c95957517">property_has_selection</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the buffer has some text currently selected.  <a href="#4a751ec1bbd2f0eecf1aab9c95957517"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::PropertyProxy_ReadOnly<br class="typebreak">
&lt;Glib::ustring&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#2573430913cc9b7744776e1c2fb1f979">property_text</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current text of the buffer.  <a href="#2573430913cc9b7744776e1c2fb1f979"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::PropertyProxy<br class="typebreak">
&lt;Glib::ustring&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#4783d052450555e56928d00de9088d2f">property_text</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current text of the buffer.  <a href="#4783d052450555e56928d00de9088d2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#96727ba3da11bfbfbfac1bb23d34f2b4">register_deserialize_tagset</a> (const Glib::ustring&amp; tagset_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function registers GTK+'s internal rich text serialization format with the passed <em>buffer</em>.  <a href="#96727ba3da11bfbfbfac1bb23d34f2b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#a839b9811cc4c29f6ca1d72506bdd25e">register_serialize_tagset</a> (const Glib::ustring&amp; tagset_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function registers GTK+'s internal rich text serialization format with the passed <em>buffer</em>.  <a href="#a839b9811cc4c29f6ca1d72506bdd25e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#2e0f4cce4c2313f57ec2f670e6e1143e">remove_all_tags</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all tags in the range between <em>start</em> and <em>end</em>.  <a href="#2e0f4cce4c2313f57ec2f670e6e1143e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#ea3cb7a24ecfcbbda5d586aa2ffbba2d">remove_selection_clipboard</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp; clipboard)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a <a class="el" href="classGtk_1_1Clipboard.html" title="The Clipboard object represents a clipboard of data shared between different processes...">Gtk::Clipboard</a> added with <a class="el" href="classGtk_1_1TextBuffer.html#d9cecd4c6d2360985966f32cad5688a8" title="Adds clipboard to the list of clipboards in which the selection contents of buffer...">add_selection_clipboard()</a>.  <a href="#ea3cb7a24ecfcbbda5d586aa2ffbba2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#29ca8940b626a3fa883abb791a52852b">remove_tag</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp; tag, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits the "remove-tag" signal.  <a href="#29ca8940b626a3fa883abb791a52852b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#cf0a04e90b58b7e9253bd5e3207254a0">remove_tag_by_name</a> (const Glib::ustring&amp; name, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextTagTable.html#58f83d7b98cf4f496a88ef63e8969d6c" title="Look up a named tag.">Gtk::TextTagTable::lookup()</a> on the buffer's tag table to get a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, then calls <a class="el" href="classGtk_1_1TextBuffer.html#29ca8940b626a3fa883abb791a52852b" title="Emits the &quot;remove-tag&quot; signal.">remove_tag()</a>.  <a href="#cf0a04e90b58b7e9253bd5e3207254a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#88b0a4096add7e8ea77098ffa5973a7f">select_range</a> (const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; ins, const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp; bound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function moves the "insert" and "selection_bound" marks simultaneously.  <a href="#88b0a4096add7e8ea77098ffa5973a7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#5b20c61b684f6924b2e97d07cddc9549">set_can_create_tags</a> (const Glib::ustring&amp; format, bool can_create_tags=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this function to allow a rich text deserialization function to create new tags in the receiving buffer.  <a href="#5b20c61b684f6924b2e97d07cddc9549"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#ca1d54bd5b4497881b11f6c313ac3112">set_modified</a> (bool setting=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to keep track of whether the buffer has been modified since the last time it was saved.  <a href="#ca1d54bd5b4497881b11f6c313ac3112"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#67c274bcdd8500d4eaf1b1d543987b0f">set_text</a> (const char* text_begin, const char* text_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the current contents of the buffer, and inserts <em>text</em> instead.  <a href="#67c274bcdd8500d4eaf1b1d543987b0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#9dc48965b1949bb54c7297e6bd1d1248">set_text</a> (const Glib::ustring&amp; text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the current contents of the buffer, and inserts <em>text</em> instead.  <a href="#9dc48965b1949bb54c7297e6bd1d1248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy3&lt; void, <br class="typebreak">
const Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp;, const <br class="typebreak">
<a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;, const <br class="typebreak">
<a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#9521321e0afc85964363806b0d161e7e">signal_apply_tag</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy0&lt;void&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#f5d34c63ae4058694f3c7ed3d7da94a3">signal_begin_user_action</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy0&lt;void&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#96d7ede78d4b2548a49e9d440957490e">signal_changed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy0&lt;void&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#6aa45ed04cdbbf9b27047b7437fb5da6">signal_end_user_action</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy2&lt; void, <br class="typebreak">
const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a> <br class="typebreak">
&amp;, const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#264464f6eecd25b6e8b12a41f66dd9f6">signal_erase</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The delete_range signal is emitted to delete a range from a <a class="el" href="classGtk_1_1TextBuffer.html" title="Multi-line attributed text that can be displayed by one or more Gtk::TextView widgets...">TextBuffer</a>.  <a href="#264464f6eecd25b6e8b12a41f66dd9f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy3&lt; void, <br class="typebreak">
const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a> <br class="typebreak">
&amp;, const Glib::ustring&amp;, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#e98f2ac411b877d418023bd9c2b0e03a">signal_insert</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy2&lt; void, <br class="typebreak">
const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a> <br class="typebreak">
&amp;, const Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a> &gt;&amp;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#6d34d70a01ba8d0d36462c61d5fa3f0c">signal_insert_child_anchor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy2&lt; void, <br class="typebreak">
const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a> <br class="typebreak">
&amp;, const Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &gt;&amp;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#9115beeba329a84f79931a343b0e030b">signal_insert_pixbuf</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy1&lt; void, <br class="typebreak">
const Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a> &gt;&amp;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#12f425e88f67b48350a7b66590308d29">signal_mark_deleted</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy2&lt; void, <br class="typebreak">
const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a> <br class="typebreak">
&amp;, const Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a> &gt;&amp;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#b8f54fe724af4c50ba390896a24e46db">signal_mark_set</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy0&lt;void&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#b51efdc6d4d18d180946b818c9078411">signal_modified_changed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SignalProxy3&lt; void, <br class="typebreak">
const Glib::RefPtr<br class="typebreak">
&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp;, const <br class="typebreak">
<a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;, const <br class="typebreak">
<a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#0e50591d26083eea8775c7f836ba9db4">signal_remove_tag</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#0c1f34a82750596b1c8c3be2f7fa3f33">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classGtk_1_1TextBuffer.html#da488c738d7311ea9cedacede3b3b03c" title="Gets the number of characters in the buffer; note that characters and bytes are not...">get_char_count()</a>.  <a href="#0c1f34a82750596b1c8c3be2f7fa3f33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#8b997d023e5072ed65efbc372ce38749">unregister_deserialize_format</a> (const Glib::ustring&amp; format)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function unregisters a rich text format that was previously registered using register_deserialize_format() or <a class="el" href="classGtk_1_1TextBuffer.html#96727ba3da11bfbfbfac1bb23d34f2b4" title="This function registers GTK+&#39;s internal rich text serialization format with the...">register_deserialize_tagset()</a>.  <a href="#8b997d023e5072ed65efbc372ce38749"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#4dfa38c996b5eb11478a8b53e0ab8917">unregister_serialize_format</a> (const Glib::ustring&amp; format)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function unregisters a rich text format that was previously registered using register_serialize_format() or <a class="el" href="classGtk_1_1TextBuffer.html#a839b9811cc4c29f6ca1d72506bdd25e" title="This function registers GTK+&#39;s internal rich text serialization format with the...">register_serialize_tagset()</a>.  <a href="#4dfa38c996b5eb11478a8b53e0ab8917"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#19d471512f12849b57c93820e000eb6c">~TextBuffer</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#c9a640942cb84ecbff7d6e166b2639fd">create</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTagTable.html">TagTable</a>&gt;&amp; tag_table)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#f25db2e069fb4c4de97de7c32bc93e8b">create</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#2b171c4fb8875be6620c4d00e3fa7629">on_apply_tag</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp; tag, const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; range_end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#6c2958bafaa8304cce894b75b456884e">on_begin_user_action</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#27f97169acd3b17994c57b4e39ff5bb5">on_changed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#af826a8af12e91e51b47629bde77e57d">on_end_user_action</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#98f98b4b99183f9d8079b63eee329c46">on_erase</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#673d6eb5c9dbf67dec2df98b259bea37">on_insert</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; pos, const Glib::ustring&amp; text, int bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#45f0f179157ad34849c78b7a5b233a51">on_insert_child_anchor</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; pos, const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&amp; anchor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#1a0999b9fc4334dfab8dcafceba1d2ab">on_insert_pixbuf</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; pos, const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&amp; pixbuf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#c7aa57c7e11c6bb786cd91415ac1e3c4">on_mark_deleted</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp; mark)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#c55e8b2bfcea40d99617f3c4490b0ab5">on_mark_set</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; location, const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp; mark)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#10a5297bdc97369787e708ef45110a5a">on_modified_changed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#1ce4201cc9daea50f2602580c1e46162">on_remove_tag</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp; tag, const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp; range_end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#3a3b8930d89219e3164a478a6455a751">TextBuffer</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTagTable.html">TagTable</a>&gt;&amp; tag_table)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#aff1f509a0cb4e93146bab120a0b4536">TextBuffer</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">Gtk::TextBuffer</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextBuffer.html#09788574b3f8d6503daf01070b33c853">wrap</a> (GtkTextBuffer* object, bool take_copy=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Glib::wrap() method for this object.  <a href="#09788574b3f8d6503daf01070b33c853"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Multi-line attributed text that can be displayed by one or more <a class="el" href="classGtk_1_1TextView.html" title="Multi-line text editing widget.">Gtk::TextView</a> widgets. 
<p>
Text in a buffer can be marked with tags. A <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextBuffer::Tag</a> is an attribute that can be applied to some range of text. For example, a tag might be called "bold" and make the text inside the tag bold. However, the tag concept is more general than that; tags don't have to affect appearance. They can instead affect the behavior of mouse and key presses, "lock" a range of text so the user can't edit it, or countless other things. A tag is represented by a <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextBuffer::Tag</a> object. One <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextBuffer::Tag</a> can be applied to any number of text ranges in any number of <a class="el" href="classGtk_1_1TextBuffer.html">Gtk::TextBuffers</a>.<p>
Each tag is stored in a <a class="el" href="classGtk_1_1TextTagTable.html">Gtk::TextBuffer::TagTable</a>. A tag table defines a set of tags that can be used together. Each buffer has one tag table associated with it; only tags from that tag table can be used with the buffer. A single tag table can be shared between multiple buffers, however.<p>
Most text manipulation is accomplished with iterators, represented by an <a class="el" href="classGtk_1_1TextIter.html">iterator</a>. The iterator can be used to navigate over characters, words, lines, and sentences.<p>
But iterators can't be used to preserve positions across buffer modifications. To preserve a position, the <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextBuffer::Mark</a> object is ideal. There are two marks built-in to GtkTextBuffer; these are named "insert" and "selection_bound" and refer to the insertion point and the boundary of the selection which is not the insertion point. If no text is selected, these two marks will be in the same position. You can manipulate what is selected and where the cursor appears by moving these marks around.<p>
Text buffers always contain at least one line, but may be empty (that is, buffers can contain zero characters). The last line in the text buffer never ends in a line separator (such as newline); the other lines in the buffer always end in a line separator. Line separators count as characters when computing character counts and character offsets. Note that some Unicode line separators are represented with multiple bytes in UTF-8, and the two-character sequence "\r\n" is also considered a line separator. <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="cc9fefd2e8f66b2e27feb1abca37a840"></a><!-- doxytag: member="Gtk::TextBuffer::ChildAnchor" ref="cc9fefd2e8f66b2e27feb1abca37a840" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a> <a class="el" href="classGtk_1_1TextChildAnchor.html">Gtk::TextBuffer::ChildAnchor</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bb8a8a5abd18b84218e12a4678dcc3c0"></a><!-- doxytag: member="Gtk::TextBuffer::iterator" ref="bb8a8a5abd18b84218e12a4678dcc3c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> <a class="el" href="classGtk_1_1TextIter.html">Gtk::TextBuffer::iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e8dd977bbf98a58d400f880ed30a946e"></a><!-- doxytag: member="Gtk::TextBuffer::Mark" ref="e8dd977bbf98a58d400f880ed30a946e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGtk_1_1TextMark.html">TextMark</a> <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextBuffer::Mark</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e218bf327872d2a5ed6e3202db2627d2"></a><!-- doxytag: member="Gtk::TextBuffer::Tag" ref="e218bf327872d2a5ed6e3202db2627d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextBuffer::Tag</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0d1ed6d2b21a7cb06d261e117a2c2672"></a><!-- doxytag: member="Gtk::TextBuffer::TagTable" ref="0d1ed6d2b21a7cb06d261e117a2c2672" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGtk_1_1TextTagTable.html">TextTagTable</a> <a class="el" href="classGtk_1_1TextTagTable.html">Gtk::TextBuffer::TagTable</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="19d471512f12849b57c93820e000eb6c"></a><!-- doxytag: member="Gtk::TextBuffer::~TextBuffer" ref="19d471512f12849b57c93820e000eb6c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gtk::TextBuffer::~TextBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aff1f509a0cb4e93146bab120a0b4536"></a><!-- doxytag: member="Gtk::TextBuffer::TextBuffer" ref="aff1f509a0cb4e93146bab120a0b4536" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextBuffer::TextBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3a3b8930d89219e3164a478a6455a751"></a><!-- doxytag: member="Gtk::TextBuffer::TextBuffer" ref="3a3b8930d89219e3164a478a6455a751" args="(const Glib::RefPtr&lt; TagTable &gt; &amp;tag_table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextBuffer::TextBuffer           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTagTable.html">TagTable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag_table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5b40599bc4daf29b2dd923deafc05e7e"></a><!-- doxytag: member="Gtk::TextBuffer::add_mark" ref="5b40599bc4daf29b2dd923deafc05e7e" args="(const Glib::RefPtr&lt; TextBuffer::Mark &gt; &amp;mark, const iterator &amp;where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::add_mark           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the mark at position <em>where</em>. 
<p>
The mark must not be added to another buffer, and if its name is not <code>0</code> then there must not be another mark in the buffer with the same name.<p>
Emits the "mark-set" signal as notification of the mark's initial placement.<p>
<dl compact><dt><b><a class="el" href="newin2p12s.html#_newin2p12s000093">Since gtkmm 2.12:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>The mark to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>Location to place mark. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d9cecd4c6d2360985966f32cad5688a8"></a><!-- doxytag: member="Gtk::TextBuffer::add_selection_clipboard" ref="d9cecd4c6d2360985966f32cad5688a8" args="(const Glib::RefPtr&lt; Clipboard &gt; &amp;clipboard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::add_selection_clipboard           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds <em>clipboard</em> to the list of clipboards in which the selection contents of <em>buffer</em> are available. 
<p>
In most cases, <em>clipboard</em> will be the <a class="el" href="classGtk_1_1Clipboard.html" title="The Clipboard object represents a clipboard of data shared between different processes...">Gtk::Clipboard</a> of type Gdk::SELECTION_PRIMARY for a view of <em>buffer</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1Clipboard.html" title="The Clipboard object represents a clipboard of data shared between different processes...">Gtk::Clipboard</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="923292fd14bf207049ed100a3d635c19"></a><!-- doxytag: member="Gtk::TextBuffer::apply_tag" ref="923292fd14bf207049ed100a3d635c19" args="(const Glib::RefPtr&lt; Tag &gt; &amp;tag, const iterator &amp;start, const iterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::apply_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits the "apply-tag" signal on <em>buffer</em>. 
<p>
The default handler for the signal applies <em>tag</em> to the given range. <em>start</em> and <em>end</em> do not have to be in order. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of range to be tagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Other bound of range to be tagged. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="322dfc3ef866789e27565be5ec639f15"></a><!-- doxytag: member="Gtk::TextBuffer::apply_tag_by_name" ref="322dfc3ef866789e27565be5ec639f15" args="(const Glib::ustring &amp;name, const iterator &amp;start, const iterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::apply_tag_by_name           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextTagTable.html#58f83d7b98cf4f496a88ef63e8969d6c" title="Look up a named tag.">Gtk::TextTagTable::lookup()</a> on the buffer's tag table to get a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, then calls <a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19" title="Emits the &quot;apply-tag&quot; signal on buffer.">apply_tag()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of a named <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of range to be tagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Other bound of range to be tagged. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e6cffbcb3b2d2fc2ba4f18e5518549aa"></a><!-- doxytag: member="Gtk::TextBuffer::assign" ref="e6cffbcb3b2d2fc2ba4f18e5518549aa" args="(const char *text_begin, const char *text_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::assign           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGtk_1_1TextBuffer.html#9dc48965b1949bb54c7297e6bd1d1248" title="Removes the current contents of the buffer, and inserts text instead.">set_text()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0df024c51b2bb46dd0288b96a5edcd7f"></a><!-- doxytag: member="Gtk::TextBuffer::assign" ref="0df024c51b2bb46dd0288b96a5edcd7f" args="(const Glib::ustring &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::assign           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGtk_1_1TextBuffer.html#9dc48965b1949bb54c7297e6bd1d1248" title="Removes the current contents of the buffer, and inserts text instead.">set_text()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ef8d2dcc85129cc399dca45a435ae24"></a><!-- doxytag: member="Gtk::TextBuffer::backspace" ref="6ef8d2dcc85129cc399dca45a435ae24" args="(const iterator &amp;iter, bool interactive=true, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::backspace           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>interactive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs the appropriate action as if the user hit the delete key with the cursor at the position specified by <em>iter</em>. 
<p>
In the normal case a single character will be deleted, but when combining accents are involved, more than one character can be deleted, and when precomposed character and accent combinations are involved, less than one character will be deleted.<p>
Because the buffer is modified, all outstanding iterators become invalid after calling this method; however, this method returns a valid iterator that points to the location where text was deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A position in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interactive</em>&nbsp;</td><td>Whether the deletion is caused by user interaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Whether the buffer is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator to the location where text was deleted, if the buffer was modified.</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p6s.html#_newin2p6s000151">Since gtkmm 2.6:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="6c6fe08e46f141bffe7c2dfeb459c074"></a><!-- doxytag: member="Gtk::TextBuffer::begin" ref="6c6fe08e46f141bffe7c2dfeb459c074" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f86f1ef86eb6a35df054287eab967902"></a><!-- doxytag: member="Gtk::TextBuffer::begin_user_action" ref="f86f1ef86eb6a35df054287eab967902" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::begin_user_action           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called to indicate that the buffer operations between here and a call to <a class="el" href="classGtk_1_1TextBuffer.html#c8a7810f527798781c28de39e5acd952" title="Should be paired with a call to begin_user_action().">end_user_action()</a> are part of a single user-visible operation. 
<p>
The operations between <a class="el" href="classGtk_1_1TextBuffer.html#f86f1ef86eb6a35df054287eab967902" title="Called to indicate that the buffer operations between here and a call to end_user_action()...">begin_user_action()</a> and <a class="el" href="classGtk_1_1TextBuffer.html#c8a7810f527798781c28de39e5acd952" title="Should be paired with a call to begin_user_action().">end_user_action()</a> can then be grouped when creating an undo stack. <a class="el" href="classGtk_1_1TextBuffer.html" title="Multi-line attributed text that can be displayed by one or more Gtk::TextView widgets...">Gtk::TextBuffer</a> maintains a count of calls to <a class="el" href="classGtk_1_1TextBuffer.html#f86f1ef86eb6a35df054287eab967902" title="Called to indicate that the buffer operations between here and a call to end_user_action()...">begin_user_action()</a> that have not been closed with a call to <a class="el" href="classGtk_1_1TextBuffer.html#c8a7810f527798781c28de39e5acd952" title="Should be paired with a call to begin_user_action().">end_user_action()</a>, and emits the "begin-user-action" and "end-user-action" signals only for the outermost pair of calls. This allows you to build user actions from other user actions.<p>
The "interactive" buffer mutation functions, such as <a class="el" href="classGtk_1_1TextBuffer.html#5ae3a0c42cf66591c116dbb5ab3efd5f" title="Like insert(), but the insertion will not occur if iter is at a non-editable location...">insert_interactive()</a>, automatically call begin/end user action around the buffer operations they perform, so there's no need to add extra calls if you user action consists solely of a single call to one of those functions. 
</div>
</div><p>
<a class="anchor" name="975778a084bdeba3600ca5fb7dbec797"></a><!-- doxytag: member="Gtk::TextBuffer::copy_clipboard" ref="975778a084bdeba3600ca5fb7dbec797" args="(const Glib::RefPtr&lt; Clipboard &gt; &amp;clipboard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::copy_clipboard           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the currently-selected text to a clipboard. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>The <a class="el" href="classGtk_1_1Clipboard.html" title="The Clipboard object represents a clipboard of data shared between different processes...">Gtk::Clipboard</a> object to copy to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c9a640942cb84ecbff7d6e166b2639fd"></a><!-- doxytag: member="Gtk::TextBuffer::create" ref="c9a640942cb84ecbff7d6e166b2639fd" args="(const Glib::RefPtr&lt; TagTable &gt; &amp;tag_table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a>&gt; Gtk::TextBuffer::create           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTagTable.html">TagTable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag_table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f25db2e069fb4c4de97de7c32bc93e8b"></a><!-- doxytag: member="Gtk::TextBuffer::create" ref="f25db2e069fb4c4de97de7c32bc93e8b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a>&gt; Gtk::TextBuffer::create           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2fee15dc2d1e21f624d1aa85ad75448c"></a><!-- doxytag: member="Gtk::TextBuffer::create_child_anchor" ref="2fee15dc2d1e21f624d1aa85ad75448c" args="(const iterator &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt; Gtk::TextBuffer::create_child_anchor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8b823989431ff4b3f904efe07e9c374a"></a><!-- doxytag: member="Gtk::TextBuffer::create_mark" ref="8b823989431ff4b3f904efe07e9c374a" args="(const iterator &amp;where, bool left_gravity=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt; Gtk::TextBuffer::create_mark           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>left_gravity</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an anonymous mark. 
<p>
Creates an anonymous mark at position <em>where</em>.<p>
If a mark has left gravity, and text is inserted at the mark's current location, the mark will be moved to the left of the newly-inserted text. If the mark has right gravity ( <em>left_gravity</em> = <code>false</code>), the mark will end up on the right of newly-inserted text. The standard left-to-right cursor is a mark with right gravity (when you type, the cursor stays on the right side of the text you're typing).<p>
Emits the "mark_set" signal as notification of the mark's initial placement. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>Location to place mark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left_gravity</em>&nbsp;</td><td>Whether the mark has left gravity. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a> object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a355a0cc0a3c1d7f7f9ded9cc157feb5"></a><!-- doxytag: member="Gtk::TextBuffer::create_mark" ref="a355a0cc0a3c1d7f7f9ded9cc157feb5" args="(const Glib::ustring &amp;mark_name, const iterator &amp;where, bool left_gravity=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt; Gtk::TextBuffer::create_mark           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>mark_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>left_gravity</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a mark at position <em>where</em>. 
<p>
The mark can be retrieved by name using <a class="el" href="classGtk_1_1TextBuffer.html#2fcefaf023f05dd2e18ffa3de6063fd0" title="Return value: a Gtk::TextMark, or 0.">get_mark()</a>. If a mark has left gravity, and text is inserted at the mark's current location, the mark will be moved to the left of the newly-inserted text. If the mark has right gravity ( <em>left_gravity</em> = <code>false</code>), the mark will end up on the right of newly-inserted text. The standard left-to-right cursor is a mark with right gravity (when you type, the cursor stays on the right side of the text you're typing).<p>
Emits the "mark_set" signal as notification of the mark's initial placement. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark_name</em>&nbsp;</td><td>Name for mark, or <code>0</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>Location to place mark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left_gravity</em>&nbsp;</td><td>Whether the mark has left gravity. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a> object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d42f4e41a4cb2d5a824e2f0ffa78e973"></a><!-- doxytag: member="Gtk::TextBuffer::create_tag" ref="d42f4e41a4cb2d5a824e2f0ffa78e973" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt; Gtk::TextBuffer::create_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an anoymous tag and adds it to the tag table for buffer. 
<p>
Equivalent to calling <a class="el" href="classGtk_1_1TextTag.html#77e074719b2411cc19d3d8751b7be2ca">Gtk::TextBuffer::Tag::create()</a> and then adding the tag to the buffer's tag table.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new tag. </dd></dl>

</div>
</div><p>
<a class="anchor" name="048bdd55d3f244e584074676ab482a2b"></a><!-- doxytag: member="Gtk::TextBuffer::create_tag" ref="048bdd55d3f244e584074676ab482a2b" args="(const Glib::ustring &amp;tag_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt; Gtk::TextBuffer::create_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a tag and adds it to the tag table for buffer. 
<p>
Equivalent to calling <a class="el" href="classGtk_1_1TextTag.html#77e074719b2411cc19d3d8751b7be2ca">Gtk::TextBuffer::Tag::create()</a> and then adding the tag to the buffer's tag table. A tag called <em>tag_name</em> must not already exist in the tag table for this buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag_name</em>&nbsp;</td><td>The name for the new tag. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new tag. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5fc2972c6f1ff379e313e5e34299f827"></a><!-- doxytag: member="Gtk::TextBuffer::cut_clipboard" ref="5fc2972c6f1ff379e313e5e34299f827" args="(const Glib::RefPtr&lt; Clipboard &gt; &amp;clipboard, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::cut_clipboard           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the currently-selected text to a clipboard, then deletes said text if it's editable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>The <a class="el" href="classGtk_1_1Clipboard.html" title="The Clipboard object represents a clipboard of data shared between different processes...">Gtk::Clipboard</a> object to cut to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Default editability of the buffer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1582cb666cbe6c857f6f742557e19295"></a><!-- doxytag: member="Gtk::TextBuffer::delete_mark" ref="1582cb666cbe6c857f6f742557e19295" args="(const Glib::RefPtr&lt; Mark &gt; &amp;mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::delete_mark           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes <em>mark</em>, so that it's no longer located anywhere in the buffer. 
<p>
Removes the reference the buffer holds to the mark, so if you don't keep a Glib::RefPtr to the mark, it will be freed. Even if the mark isn't freed, most operations on <em>mark</em> become invalid. There is no way to undelete a mark. <a class="el" href="classGtk_1_1TextMark.html#ec24e44776091f4b8ae323fabdb536e9" title="Return value: whether the mark is deleted.">Gtk::TextMark::get_deleted()</a> will return <code>true</code> after this function has been called on a mark; <a class="el" href="classGtk_1_1TextMark.html#ec24e44776091f4b8ae323fabdb536e9" title="Return value: whether the mark is deleted.">Gtk::TextMark::get_deleted()</a> indicates that a mark no longer belongs to a buffer. The "mark_deleted" signal will be emitted as notification after the mark is deleted. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a> in <em>buffer</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0ebfbbe158f0b53b14123158f6633661"></a><!-- doxytag: member="Gtk::TextBuffer::delete_mark_by_name" ref="0ebfbbe158f0b53b14123158f6633661" args="(const Glib::ustring &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::delete_mark_by_name           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the mark named <em>name</em>; the mark must exist. 
<p>
See <a class="el" href="classGtk_1_1TextBuffer.html#1582cb666cbe6c857f6f742557e19295" title="Deletes mark, so that it&#39;s no longer located anywhere in the buffer.">delete_mark()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of a mark in <em>buffer</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c4ee0ba09f7d8d316e3db8b7402344a2"></a><!-- doxytag: member="Gtk::TextBuffer::end" ref="c4ee0ba09f7d8d316e3db8b7402344a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c8a7810f527798781c28de39e5acd952"></a><!-- doxytag: member="Gtk::TextBuffer::end_user_action" ref="c8a7810f527798781c28de39e5acd952" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::end_user_action           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Should be paired with a call to <a class="el" href="classGtk_1_1TextBuffer.html#f86f1ef86eb6a35df054287eab967902" title="Called to indicate that the buffer operations between here and a call to end_user_action()...">begin_user_action()</a>. 
<p>
See that function for a full explanation. 
</div>
</div><p>
<a class="anchor" name="93a0c92f1f46b3efaf86fcbcf746db77"></a><!-- doxytag: member="Gtk::TextBuffer::erase" ref="93a0c92f1f46b3efaf86fcbcf746db77" args="(const iterator &amp;range_begin, const iterator &amp;range_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b9e12682d654a53fc46ab36434047666"></a><!-- doxytag: member="Gtk::TextBuffer::erase_interactive" ref="b9e12682d654a53fc46ab36434047666" args="(const iterator &amp;range_begin, const iterator &amp;range_end, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>,bool&gt; Gtk::TextBuffer::erase_interactive           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="371236bd4146f5520bda252d1c50d309"></a><!-- doxytag: member="Gtk::TextBuffer::erase_selection" ref="371236bd4146f5520bda252d1c50d309" args="(bool interactive=true, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextBuffer::erase_selection           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>interactive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the range between the "insert" and "selection_bound" marks, that is, the currently-selected text. 
<p>
If <em>interactive</em> is <code>true</code>, the editability of the selection will be considered (users can't delete uneditable text). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interactive</em>&nbsp;</td><td>Whether the deletion is caused by user interaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Whether the buffer is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether there was a non-empty selection to delete. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a57d47ab3cf08829430d90fe446f41ee"></a><!-- doxytag: member="Gtk::TextBuffer::get_bounds" ref="a57d47ab3cf08829430d90fe446f41ee" args="(iterator &amp;range_begin, iterator &amp;range_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::get_bounds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="797303ae5468bda67b625d54fedec62b"></a><!-- doxytag: member="Gtk::TextBuffer::get_can_create_tags" ref="797303ae5468bda67b625d54fedec62b" args="(const Glib::ustring &amp;format) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextBuffer::get_can_create_tags           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>format</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This functions returns the value set with deserialize_set_can_create_tags(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>A Gdk::Atom representing a registered rich text format. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether deserializing this format may create tags</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000370">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="da488c738d7311ea9cedacede3b3b03c"></a><!-- doxytag: member="Gtk::TextBuffer::get_char_count" ref="da488c738d7311ea9cedacede3b3b03c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextBuffer::get_char_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of characters in the buffer; note that characters and bytes are not the same, you can't e.g. expect the contents of the buffer in string form to be this many bytes long. 
<p>
The character count is cached, so this function is very fast. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters in the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5b0254f594094d50a3bfab30190009df"></a><!-- doxytag: member="Gtk::TextBuffer::get_deserialize_formats" ref="5b0254f594094d50a3bfab30190009df" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::StringArrayHandle Gtk::TextBuffer::get_deserialize_formats           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="44414f75c6ec2f1758832e8935b169cd"></a><!-- doxytag: member="Gtk::TextBuffer::get_has_selection" ref="44414f75c6ec2f1758832e8935b169cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextBuffer::get_has_selection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether the buffer has some text currently selected. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the there is text selected</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000364">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="4b92f14603f572f99daf0c86abd1b9ad"></a><!-- doxytag: member="Gtk::TextBuffer::get_insert" ref="4b92f14603f572f99daf0c86abd1b9ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt; Gtk::TextBuffer::get_insert           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: insertion point mark. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Insertion point mark. </dd></dl>

</div>
</div><p>
<a class="anchor" name="adecf4e2baa4eb964e3952896561322f"></a><!-- doxytag: member="Gtk::TextBuffer::get_iter_at_child_anchor" ref="adecf4e2baa4eb964e3952896561322f" args="(const Glib::RefPtr&lt; ChildAnchor &gt; &amp;anchor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::get_iter_at_child_anchor           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>anchor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current position of an anchor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anchor</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextChildAnchor.html">Gtk::TextBuffer::Anchor</a> that appears in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator that points to the position of the <em>anchor</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="77ebbbdc688b1f2d16fbbd7e048efc4f"></a><!-- doxytag: member="Gtk::TextBuffer::get_iter_at_line" ref="77ebbbdc688b1f2d16fbbd7e048efc4f" args="(int line_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::get_iter_at_line           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6ad8b4b329a6183834812ebbdc74c8cf"></a><!-- doxytag: member="Gtk::TextBuffer::get_iter_at_line_index" ref="6ad8b4b329a6183834812ebbdc74c8cf" args="(int line_number, int byte_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::get_iter_at_line_index           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byte_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b0b39b1914fd24c7f4a4f3c05d751d93"></a><!-- doxytag: member="Gtk::TextBuffer::get_iter_at_line_offset" ref="b0b39b1914fd24c7f4a4f3c05d751d93" args="(int line_number, int char_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::get_iter_at_line_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="331fadf0c7c6c470b709802fbc09984a"></a><!-- doxytag: member="Gtk::TextBuffer::get_iter_at_mark" ref="331fadf0c7c6c470b709802fbc09984a" args="(const Glib::RefPtr&lt; Mark &gt; &amp;mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::get_iter_at_mark           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current position of a mark. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>The <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextBuffer::Mark</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator that points to the position of the <em>mark</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e92edc6a06a9a5fae2ee99f762bb59ff"></a><!-- doxytag: member="Gtk::TextBuffer::get_iter_at_offset" ref="e92edc6a06a9a5fae2ee99f762bb59ff" args="(int char_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::get_iter_at_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f69d5132c5439d356dedcbfcc7197fc3"></a><!-- doxytag: member="Gtk::TextBuffer::get_line_count" ref="f69d5132c5439d356dedcbfcc7197fc3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextBuffer::get_line_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the number of lines in the buffer. 
<p>
This value is cached, so the function is very fast. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of lines in the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="42f3ec0e6acacc18bd90a646847b3a7c"></a><!-- doxytag: member="Gtk::TextBuffer::get_mark" ref="42f3ec0e6acacc18bd90a646847b3a7c" args="(const Glib::ustring &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt; Gtk::TextBuffer::get_mark           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: a <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>, or <code>0</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A mark name. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>, or <code>0</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fcefaf023f05dd2e18ffa3de6063fd0"></a><!-- doxytag: member="Gtk::TextBuffer::get_mark" ref="2fcefaf023f05dd2e18ffa3de6063fd0" args="(const Glib::ustring &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt; Gtk::TextBuffer::get_mark           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: a <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>, or <code>0</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A mark name. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>, or <code>0</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2170f20b9a330679596ef61863f6e101"></a><!-- doxytag: member="Gtk::TextBuffer::get_modified" ref="2170f20b9a330679596ef61863f6e101" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextBuffer::get_modified           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether the buffer has been modified since the last call to <a class="el" href="classGtk_1_1TextBuffer.html#ca1d54bd5b4497881b11f6c313ac3112" title="Used to keep track of whether the buffer has been modified since the last time it...">set_modified()</a> set the modification flag to <code>false</code>. 
<p>
Used for example to enable a "save" function in a text editor. <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the buffer has been modified. </dd></dl>

</div>
</div><p>
<a class="anchor" name="59f49dbb4f753a1d523f68de91c4fe9d"></a><!-- doxytag: member="Gtk::TextBuffer::get_selection_bound" ref="59f49dbb4f753a1d523f68de91c4fe9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt; Gtk::TextBuffer::get_selection_bound           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: selection bound mark. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Selection bound mark. </dd></dl>

</div>
</div><p>
<a class="anchor" name="09d9a9132d21deee1c34baff9b20f8e0"></a><!-- doxytag: member="Gtk::TextBuffer::get_selection_bounds" ref="09d9a9132d21deee1c34baff9b20f8e0" args="(iterator &amp;start, iterator &amp;end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextBuffer::get_selection_bounds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether the selection has nonzero length. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Iterator to initialize with selection start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Iterator to initialize with selection end. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the selection has nonzero length. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41b8005355c29cfa61455a6dd354ca6a"></a><!-- doxytag: member="Gtk::TextBuffer::get_serialize_formats" ref="41b8005355c29cfa61455a6dd354ca6a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::StringArrayHandle Gtk::TextBuffer::get_serialize_formats           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e1cbe191e2e2c739704d4e7fff366b06"></a><!-- doxytag: member="Gtk::TextBuffer::get_slice" ref="e1cbe191e2e2c739704d4e7fff366b06" args="(const iterator &amp;start, const iterator &amp;end, bool include_hidden_chars=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::get_slice           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: an allocated UTF-8 string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>include_hidden_chars</em>&nbsp;</td><td>Whether to include invisible text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated UTF-8 string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b07f68f1c4705bdfe7271eaeb36d65e5"></a><!-- doxytag: member="Gtk::TextBuffer::get_slice" ref="b07f68f1c4705bdfe7271eaeb36d65e5" args="(const iterator &amp;start, const iterator &amp;end, bool include_hidden_chars=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::get_slice           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: an allocated UTF-8 string. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGtk_1_1TextBuffer.html#e1cbe191e2e2c739704d4e7fff366b06" title="Return value: an allocated UTF-8 string.">get_slice(const iterator&amp; start, const iterator&amp; end, bool include_hidden_chars) const</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>include_hidden_chars</em>&nbsp;</td><td>Whether to include invisible text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated UTF-8 string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a242143c1cdbeb925f47704bf08b436e"></a><!-- doxytag: member="Gtk::TextBuffer::get_tag_table" ref="a242143c1cdbeb925f47704bf08b436e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTagTable.html">TextBuffer::TagTable</a>&gt; Gtk::TextBuffer::get_tag_table           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classGtk_1_1TextTagTable.html" title="Typedefed as Gtk::TextBuffer::TagTable.">Gtk::TextTagTable</a> associated with this buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The buffer's tag table. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3103df31b1a0fc808997fd9da44e4734"></a><!-- doxytag: member="Gtk::TextBuffer::get_tag_table" ref="3103df31b1a0fc808997fd9da44e4734" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTagTable.html">TextBuffer::TagTable</a>&gt; Gtk::TextBuffer::get_tag_table           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classGtk_1_1TextTagTable.html" title="Typedefed as Gtk::TextBuffer::TagTable.">Gtk::TextTagTable</a> associated with this buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The buffer's tag table. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fd3c4c2a218879e74ffe2e60786adb0b"></a><!-- doxytag: member="Gtk::TextBuffer::get_text" ref="fd3c4c2a218879e74ffe2e60786adb0b" args="(bool include_hidden_chars=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::get_text           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns all the text in the buffer. 
<p>
Excludes undisplayed text (text marked with tags that set the invisibility attribute) if <em>include_hidden_chars</em> is <code>false</code>. Does not include characters representing embedded images, so byte and character indexes into the returned string do <em>not</em> correspond to byte and character indexes into the buffer. Contrast with <a class="el" href="classGtk_1_1TextBuffer.html#b07f68f1c4705bdfe7271eaeb36d65e5" title="Return value: an allocated UTF-8 string.">get_slice()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>include_hidden_chars</em>&nbsp;</td><td>Whether to include invisible text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated UTF-8 string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="77434f057d68314a823ae47da426013a"></a><!-- doxytag: member="Gtk::TextBuffer::get_text" ref="77434f057d68314a823ae47da426013a" args="(bool include_hidden_chars=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::get_text           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGtk_1_1TextBuffer.html#fd3c4c2a218879e74ffe2e60786adb0b" title="Returns all the text in the buffer.">get_text(bool include_hidden_chars) const</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e6eb888811a3060cf6525c71bda319a"></a><!-- doxytag: member="Gtk::TextBuffer::get_text" ref="5e6eb888811a3060cf6525c71bda319a" args="(const iterator &amp;start, const iterator &amp;end, bool include_hidden_chars=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::get_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: an allocated UTF-8 string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>include_hidden_chars</em>&nbsp;</td><td>Whether to include invisible text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated UTF-8 string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e4f9e04000110dbfd1014ef05067a593"></a><!-- doxytag: member="Gtk::TextBuffer::get_text" ref="e4f9e04000110dbfd1014ef05067a593" args="(const iterator &amp;start, const iterator &amp;end, bool include_hidden_chars=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::get_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_hidden_chars</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: an allocated UTF-8 string. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGtk_1_1TextBuffer.html#5e6eb888811a3060cf6525c71bda319a" title="Return value: an allocated UTF-8 string.">get_text(const iterator&amp; start, const iterator&amp; end, bool include_hidden_chars) const</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of a range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>include_hidden_chars</em>&nbsp;</td><td>Whether to include invisible text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated UTF-8 string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="002e580ebeb7884bfdb8d5bc5d4122fa"></a><!-- doxytag: member="Gtk::TextBuffer::gobj" ref="002e580ebeb7884bfdb8d5bc5d4122fa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GtkTextBuffer* Gtk::TextBuffer::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

</div>
</div><p>
<a class="anchor" name="9250bc4defcf6599e94a37b0d3caaa1d"></a><!-- doxytag: member="Gtk::TextBuffer::gobj" ref="9250bc4defcf6599e94a37b0d3caaa1d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GtkTextBuffer* Gtk::TextBuffer::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

</div>
</div><p>
<a class="anchor" name="3e79c9310e23f741898f081689b07672"></a><!-- doxytag: member="Gtk::TextBuffer::gobj_copy" ref="3e79c9310e23f741898f081689b07672" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GtkTextBuffer* Gtk::TextBuffer::gobj_copy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. 
<p>

</div>
</div><p>
<a class="anchor" name="aad9d1eb6498a68ec43cdbdab9199679"></a><!-- doxytag: member="Gtk::TextBuffer::insert" ref="aad9d1eb6498a68ec43cdbdab9199679" args="(const iterator &amp;pos, const iterator &amp;range_begin, const iterator &amp;range_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies text, tags, and pixbufs between <em>range_begin</em> and <em>range_end</em> (the order of range_begin and range_begin doesn't matter) and inserts the copy at <em>pos</em>. 
<p>
Used instead of simply getting/inserting text because it preserves images and tags. If range_begin and range_end are in a different buffer, the two buffers must share the same tag table.<p>
Implemented via emissions of the insert_text and apply_tag signals, so expect those.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range_begin</em>&nbsp;</td><td>A position in a buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range_end</em>&nbsp;</td><td>Another position in the same buffer as <em>range_begin</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="22492c63d1f0da2f04231d9ec4cbecc8"></a><!-- doxytag: member="Gtk::TextBuffer::insert" ref="22492c63d1f0da2f04231d9ec4cbecc8" args="(const iterator &amp;pos, const char *text_begin, const char *text_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text at position <em>pos</em>. 
<p>
Emits the "insert_text" signal; insertion actually occurs in the default handler for the signal. The <em>pos</em> iterator is invalidated when insertion occurs (because the buffer contents change).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_begin</em>&nbsp;</td><td>The start of a UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_end</em>&nbsp;</td><td>The end of the UTF8 character array. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator that points to the end of the inserted text. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6466a773421e4d48994b65f4a1703ce"></a><!-- doxytag: member="Gtk::TextBuffer::insert" ref="c6466a773421e4d48994b65f4a1703ce" args="(const iterator &amp;pos, const Glib::ustring &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <em>text</em> at position <em>pos</em>. 
<p>
Emits the "insert_text" signal; insertion actually occurs in the default handler for the signal. The <em>pos</em> iterator is invalidated when insertion occurs (because the buffer contents change).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be inserted in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator that points to the end of the inserted text. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9302a066984dd922034bf51c668ae17c"></a><!-- doxytag: member="Gtk::TextBuffer::insert_at_cursor" ref="9302a066984dd922034bf51c668ae17c" args="(const char *text_begin, const char *text_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::insert_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text, using the current cursor position as the insertion point. 
<p>
Emits the "insert_text" signal; insertion actually occurs in the default handler for the signal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text_begin</em>&nbsp;</td><td>The start of a UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_end</em>&nbsp;</td><td>The end of the UTF8 character array. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator that points to the end of the inserted text. </dd></dl>

</div>
</div><p>
<a class="anchor" name="53360179e6441863cec6117c6f396af0"></a><!-- doxytag: member="Gtk::TextBuffer::insert_at_cursor" ref="53360179e6441863cec6117c6f396af0" args="(const Glib::ustring &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::insert_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <em>text</em>, using the current cursor position as the insertion point. 
<p>
Emits the "insert_text" signal; insertion actually occurs in the default handler for the signal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be inserted in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator that points to the end of the inserted text. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80afdb5f6a08477a1977b88982069fdd"></a><!-- doxytag: member="Gtk::TextBuffer::insert_child_anchor" ref="80afdb5f6a08477a1977b88982069fdd" args="(const iterator &amp;pos, const Glib::RefPtr&lt; ChildAnchor &gt; &amp;anchor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_child_anchor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>anchor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ffa78900d98dd158b1f78c7977a535dd"></a><!-- doxytag: member="Gtk::TextBuffer::insert_interactive" ref="ffa78900d98dd158b1f78c7977a535dd" args="(const iterator &amp;pos, const iterator &amp;range_begin, const iterator &amp;range_end, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>,bool&gt; Gtk::TextBuffer::insert_interactive           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as insert_range(), but does nothing if the insertion point isn't editable. 
<p>
The <em>default_editable</em> parameter indicates whether the text is editable at <em>pos</em> if no tags enclosing <em>pos</em> affect editability. Typically the result of <a class="el" href="classGtk_1_1TextView.html#4801b2e560f0dca18e4dff751afcf241" title="Return value: whether text is editable by default.">Gtk::TextView::get_editable()</a> is appropriate here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range_begin</em>&nbsp;</td><td>A position in a buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range_end</em>&nbsp;</td><td>Another position in the same buffer as <em>range_begin</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Default editability of buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="5dd1053539bc3c7b306b26047f5c2725"></a><!-- doxytag: member="Gtk::TextBuffer::insert_interactive" ref="5dd1053539bc3c7b306b26047f5c2725" args="(const iterator &amp;pos, const char *text_begin, const char *text_end, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>,bool&gt; Gtk::TextBuffer::insert_interactive           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, but the insertion will not occur if <em>pos</em> is at a non-editable location in the buffer. 
<p>
Usually you want to prevent insertions at ineditable locations if the insertion results from a user action (is interactive).<p>
<em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classGtk_1_1TextView.html#4801b2e560f0dca18e4dff751afcf241" title="Return value: whether text is editable by default.">Gtk::TextView::get_editable()</a> is appropriate here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_begin</em>&nbsp;</td><td>The start of a UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_end</em>&nbsp;</td><td>The end of the UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Default editability of buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ae3a0c42cf66591c116dbb5ab3efd5f"></a><!-- doxytag: member="Gtk::TextBuffer::insert_interactive" ref="5ae3a0c42cf66591c116dbb5ab3efd5f" args="(const iterator &amp;pos, const Glib::ustring &amp;text, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classGtk_1_1TextIter.html">iterator</a>,bool&gt; Gtk::TextBuffer::insert_interactive           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, but the insertion will not occur if <em>iter</em> is at a non-editable location in the buffer. 
<p>
Usually you want to prevent insertions at ineditable locations if the insertion results from a user action (is interactive).<p>
<em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classGtk_1_1TextView.html#4801b2e560f0dca18e4dff751afcf241" title="Return value: whether text is editable by default.">Gtk::TextView::get_editable()</a> is appropriate here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be inserted in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Default editability of buffer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c775f5341888798b1425cb6e8091060"></a><!-- doxytag: member="Gtk::TextBuffer::insert_interactive_at_cursor" ref="8c775f5341888798b1425cb6e8091060" args="(const char *text_begin, const char *text_end, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextBuffer::insert_interactive_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextBuffer.html#5ae3a0c42cf66591c116dbb5ab3efd5f" title="Like insert(), but the insertion will not occur if iter is at a non-editable location...">insert_interactive()</a> at the cursor position. 
<p>
<em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classGtk_1_1TextView.html#4801b2e560f0dca18e4dff751afcf241" title="Return value: whether text is editable by default.">Gtk::TextView::get_editable()</a> is appropriate here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text_begin</em>&nbsp;</td><td>The start of a UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_end</em>&nbsp;</td><td>The end of the UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Default editability of buffer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="07f6c4236a1ede7e4e5ced196b13bc76"></a><!-- doxytag: member="Gtk::TextBuffer::insert_interactive_at_cursor" ref="07f6c4236a1ede7e4e5ced196b13bc76" args="(const Glib::ustring &amp;text, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextBuffer::insert_interactive_at_cursor           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextBuffer.html#5ae3a0c42cf66591c116dbb5ab3efd5f" title="Like insert(), but the insertion will not occur if iter is at a non-editable location...">insert_interactive()</a> at the cursor position. 
<p>
<em>default_editable</em> indicates the editability of text that doesn't have a tag affecting editability applied to it. Typically the result of <a class="el" href="classGtk_1_1TextView.html#4801b2e560f0dca18e4dff751afcf241" title="Return value: whether text is editable by default.">Gtk::TextView::get_editable()</a> is appropriate here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be inserted in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_editable</em>&nbsp;</td><td>Default editability of buffer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b2b44341f6fd7d423b6c3a9afa7aa36"></a><!-- doxytag: member="Gtk::TextBuffer::insert_pixbuf" ref="8b2b44341f6fd7d423b6c3a9afa7aa36" args="(const iterator &amp;pos, const Glib::RefPtr&lt; Gdk::Pixbuf &gt; &amp;pixbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>pixbuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8b50becdec017a20a88c8279def83249"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tag" ref="8b50becdec017a20a88c8279def83249" args="(const iterator &amp;pos, const char *text_begin, const char *text_end, const Glib::ustring &amp;tag_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="134f2de521d6a00ebf2da802481cef3d"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tag" ref="134f2de521d6a00ebf2da802481cef3d" args="(const iterator &amp;pos, const Glib::ustring &amp;text, const Glib::ustring &amp;tag_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e689b9324620f5b1daa1fac9d13c8130"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tag" ref="e689b9324620f5b1daa1fac9d13c8130" args="(const iterator &amp;pos, const char *text_begin, const char *text_end, const Glib::RefPtr&lt; Tag &gt; &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="79771152944a1d16d5119e1314295c39"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tag" ref="79771152944a1d16d5119e1314295c39" args="(const iterator &amp;pos, const Glib::ustring &amp;text, const Glib::RefPtr&lt; Tag &gt; &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8bf700ece48eb05024521f4f7fa62a7e"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tags" ref="8bf700ece48eb05024521f4f7fa62a7e" args="(const iterator &amp;pos, const char *text_begin, const char *text_end, const Glib::ArrayHandle&lt; Glib::RefPtr&lt; Tag &gt; &gt; &amp;tags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tags           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ArrayHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text into buffer at <em>pos</em>, applying the list of tags to the newly-inserted text. 
<p>
Equivalent to calling <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, then <a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19" title="Emits the &quot;apply-tag&quot; signal on buffer.">apply_tag()</a> on the inserted text; This is just a convenience function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_begin</em>&nbsp;</td><td>The start of a UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_end</em>&nbsp;</td><td>The end of the UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tags</em>&nbsp;</td><td>A standard C++ container of <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextBuffer::Tags</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="afa889a4f2cf65344970cad54b5113b9"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tags" ref="afa889a4f2cf65344970cad54b5113b9" args="(const iterator &amp;pos, const Glib::ustring &amp;text, const Glib::ArrayHandle&lt; Glib::RefPtr&lt; Tag &gt; &gt; &amp;tags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tags           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ArrayHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text into buffer at <em>pos</em>, applying the list of tags to the newly-inserted text. 
<p>
Equivalent to calling <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, then <a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19" title="Emits the &quot;apply-tag&quot; signal on buffer.">apply_tag()</a> on the inserted text; This is just a convenience function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be inserted in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tags</em>&nbsp;</td><td>A standard C++ container of <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextBuffer::Tags</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="3db6bb55ac970ecf5a9ff76983910202"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tags_by_name" ref="3db6bb55ac970ecf5a9ff76983910202" args="(const iterator &amp;pos, const char *text_begin, const char *text_end, const Glib::StringArrayHandle &amp;tag_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tags_by_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::StringArrayHandle &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_names</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to calling <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, then <a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19" title="Emits the &quot;apply-tag&quot; signal on buffer.">apply_tag()</a> on the inserted text; This is just a convenience function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_begin</em>&nbsp;</td><td>The start of a UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_end</em>&nbsp;</td><td>The end of the UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_names</em>&nbsp;</td><td>A standard C++ container of tag names. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="1bd15350e31b677150b6608eded9cfb2"></a><!-- doxytag: member="Gtk::TextBuffer::insert_with_tags_by_name" ref="1bd15350e31b677150b6608eded9cfb2" args="(const iterator &amp;pos, const Glib::ustring &amp;text, const Glib::StringArrayHandle &amp;tag_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">iterator</a> Gtk::TextBuffer::insert_with_tags_by_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::StringArrayHandle &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_names</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts text into buffer at <em>pos</em>, applying the list of tags to the newly-inserted text. 
<p>
Equivalent to calling <a class="el" href="classGtk_1_1TextBuffer.html#c6466a773421e4d48994b65f4a1703ce" title="Inserts text at position pos.">insert()</a>, then <a class="el" href="classGtk_1_1TextBuffer.html#923292fd14bf207049ed100a3d635c19" title="Emits the &quot;apply-tag&quot; signal on buffer.">apply_tag()</a> on the inserted text; This is just a convenience function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>An iterator pointing to the position at which the text should be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be inserted in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_names</em>&nbsp;</td><td>A standard C++ container of tag names. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text was actually inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="82c1011da5758549e634729dcbc70839"></a><!-- doxytag: member="Gtk::TextBuffer::move_mark" ref="82c1011da5758549e634729dcbc70839" args="(const Glib::RefPtr&lt; Mark &gt; &amp;mark, const iterator &amp;where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::move_mark           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">Mark</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>mark</em> to the new location <em>where</em>. 
<p>
Emits the "mark-set" signal as notification of the move. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>New location for <em>mark</em> in <em>buffer</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="de83a7b96d0b4888de0f96cd3e0b7220"></a><!-- doxytag: member="Gtk::TextBuffer::move_mark_by_name" ref="de83a7b96d0b4888de0f96cd3e0b7220" args="(const Glib::ustring &amp;name, const iterator &amp;where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::move_mark_by_name           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the mark named <em>name</em> (which must exist) to location <em>where</em>. 
<p>
See <a class="el" href="classGtk_1_1TextBuffer.html#82c1011da5758549e634729dcbc70839" title="Moves mark to the new location where.">move_mark()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of a mark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>New location for mark. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b171c4fb8875be6620c4d00e3fa7629"></a><!-- doxytag: member="Gtk::TextBuffer::on_apply_tag" ref="2b171c4fb8875be6620c4d00e3fa7629" args="(const Glib::RefPtr&lt; TextBuffer::Tag &gt; &amp;tag, const TextBuffer::iterator &amp;range_begin, const TextBuffer::iterator &amp;range_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_apply_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6c2958bafaa8304cce894b75b456884e"></a><!-- doxytag: member="Gtk::TextBuffer::on_begin_user_action" ref="6c2958bafaa8304cce894b75b456884e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_begin_user_action           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="27f97169acd3b17994c57b4e39ff5bb5"></a><!-- doxytag: member="Gtk::TextBuffer::on_changed" ref="27f97169acd3b17994c57b4e39ff5bb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_changed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="af826a8af12e91e51b47629bde77e57d"></a><!-- doxytag: member="Gtk::TextBuffer::on_end_user_action" ref="af826a8af12e91e51b47629bde77e57d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_end_user_action           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="98f98b4b99183f9d8079b63eee329c46"></a><!-- doxytag: member="Gtk::TextBuffer::on_erase" ref="98f98b4b99183f9d8079b63eee329c46" args="(const TextBuffer::iterator &amp;start, const TextBuffer::iterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="673d6eb5c9dbf67dec2df98b259bea37"></a><!-- doxytag: member="Gtk::TextBuffer::on_insert" ref="673d6eb5c9dbf67dec2df98b259bea37" args="(const TextBuffer::iterator &amp;pos, const Glib::ustring &amp;text, int bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="45f0f179157ad34849c78b7a5b233a51"></a><!-- doxytag: member="Gtk::TextBuffer::on_insert_child_anchor" ref="45f0f179157ad34849c78b7a5b233a51" args="(const TextBuffer::iterator &amp;pos, const Glib::RefPtr&lt; ChildAnchor &gt; &amp;anchor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_insert_child_anchor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>anchor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1a0999b9fc4334dfab8dcafceba1d2ab"></a><!-- doxytag: member="Gtk::TextBuffer::on_insert_pixbuf" ref="1a0999b9fc4334dfab8dcafceba1d2ab" args="(const TextBuffer::iterator &amp;pos, const Glib::RefPtr&lt; Gdk::Pixbuf &gt; &amp;pixbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_insert_pixbuf           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>pixbuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c7aa57c7e11c6bb786cd91415ac1e3c4"></a><!-- doxytag: member="Gtk::TextBuffer::on_mark_deleted" ref="c7aa57c7e11c6bb786cd91415ac1e3c4" args="(const Glib::RefPtr&lt; TextBuffer::Mark &gt; &amp;mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_mark_deleted           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c55e8b2bfcea40d99617f3c4490b0ab5"></a><!-- doxytag: member="Gtk::TextBuffer::on_mark_set" ref="c55e8b2bfcea40d99617f3c4490b0ab5" args="(const TextBuffer::iterator &amp;location, const Glib::RefPtr&lt; TextBuffer::Mark &gt; &amp;mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_mark_set           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>mark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="10a5297bdc97369787e708ef45110a5a"></a><!-- doxytag: member="Gtk::TextBuffer::on_modified_changed" ref="10a5297bdc97369787e708ef45110a5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_modified_changed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1ce4201cc9daea50f2602580c1e46162"></a><!-- doxytag: member="Gtk::TextBuffer::on_remove_tag" ref="1ce4201cc9daea50f2602580c1e46162" args="(const Glib::RefPtr&lt; TextBuffer::Tag &gt; &amp;tag, const TextBuffer::iterator &amp;range_begin, const TextBuffer::iterator &amp;range_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TextBuffer::on_remove_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>range_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="45969585013f07f44f7c82543cc4aa8d"></a><!-- doxytag: member="Gtk::TextBuffer::paste_clipboard" ref="45969585013f07f44f7c82543cc4aa8d" args="(const Glib::RefPtr&lt; Clipboard &gt; &amp;clipboard, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::paste_clipboard           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="315769f47795001dc1a9449df4c22231"></a><!-- doxytag: member="Gtk::TextBuffer::paste_clipboard" ref="315769f47795001dc1a9449df4c22231" args="(const Glib::RefPtr&lt; Clipboard &gt; &amp;clipboard, const iterator &amp;override_location, bool default_editable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::paste_clipboard           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>override_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editable</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1dff95f7dc9ea889a25596a87b2f8c35"></a><!-- doxytag: member="Gtk::TextBuffer::place_cursor" ref="1dff95f7dc9ea889a25596a87b2f8c35" args="(const iterator &amp;where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::place_cursor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function moves the "insert" and "selection_bound" marks simultaneously. 
<p>
If you move them to the same place in two steps with <a class="el" href="classGtk_1_1TextBuffer.html#82c1011da5758549e634729dcbc70839" title="Moves mark to the new location where.">move_mark()</a>, you will temporarily select a region in between their old and new locations, which can be pretty inefficient since the temporarily-selected region will force stuff to be recalculated. This function moves them as a unit, which can be optimized. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>Where to put the cursor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f118d392de01d035844edf11cc14929"></a><!-- doxytag: member="Gtk::TextBuffer::property_cursor_position" ref="7f118d392de01d035844edf11cc14929" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy_ReadOnly&lt;int&gt; Gtk::TextBuffer::property_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The position of the insert mark (as offset from the beginning of the buffer). 
<p>
You rarely need to use properties because there are get_ and set_ methods for almost all of them. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a751ec1bbd2f0eecf1aab9c95957517"></a><!-- doxytag: member="Gtk::TextBuffer::property_has_selection" ref="4a751ec1bbd2f0eecf1aab9c95957517" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy_ReadOnly&lt;bool&gt; Gtk::TextBuffer::property_has_selection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the buffer has some text currently selected. 
<p>
You rarely need to use properties because there are get_ and set_ methods for almost all of them. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2573430913cc9b7744776e1c2fb1f979"></a><!-- doxytag: member="Gtk::TextBuffer::property_text" ref="2573430913cc9b7744776e1c2fb1f979" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy_ReadOnly&lt;Glib::ustring&gt; Gtk::TextBuffer::property_text           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current text of the buffer. 
<p>
You rarely need to use properties because there are get_ and set_ methods for almost all of them. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4783d052450555e56928d00de9088d2f"></a><!-- doxytag: member="Gtk::TextBuffer::property_text" ref="4783d052450555e56928d00de9088d2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy&lt;Glib::ustring&gt; Gtk::TextBuffer::property_text           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current text of the buffer. 
<p>
You rarely need to use properties because there are get_ and set_ methods for almost all of them. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="96727ba3da11bfbfbfac1bb23d34f2b4"></a><!-- doxytag: member="Gtk::TextBuffer::register_deserialize_tagset" ref="96727ba3da11bfbfbfac1bb23d34f2b4" args="(const Glib::ustring &amp;tagset_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::register_deserialize_tagset           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>tagset_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function registers GTK+'s internal rich text serialization format with the passed <em>buffer</em>. 
<p>
See <a class="el" href="classGtk_1_1TextBuffer.html#a839b9811cc4c29f6ca1d72506bdd25e" title="This function registers GTK+&#39;s internal rich text serialization format with the...">register_serialize_tagset()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagset_name</em>&nbsp;</td><td>An optional tagset name, on <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Gdk::Atom that corresponds to the newly registered format's mime-type.</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000366">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="a839b9811cc4c29f6ca1d72506bdd25e"></a><!-- doxytag: member="Gtk::TextBuffer::register_serialize_tagset" ref="a839b9811cc4c29f6ca1d72506bdd25e" args="(const Glib::ustring &amp;tagset_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextBuffer::register_serialize_tagset           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>tagset_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function registers GTK+'s internal rich text serialization format with the passed <em>buffer</em>. 
<p>
The internal format does not comply to any standard rich text format and only works between <a class="el" href="classGtk_1_1TextBuffer.html" title="Multi-line attributed text that can be displayed by one or more Gtk::TextView widgets...">Gtk::TextBuffer</a> instances. It is capable of serializing all of a text buffer's tags and embedded pixbufs.<p>
This function is just a wrapper around register_serialize_format(). The mime type used for registering is "application/x-gtk-text-buffer-rich-text", or "application/x-gtk-text-buffer-rich-text;format= @a tagset_name" if a <em>tagset_name</em> was passed.<p>
The <em>tagset_name</em> can be used to restrict the transfer of rich text to buffers with compatible sets of tags, in order to avoid unknown tags from being pasted. It is probably the common case to pass an identifier != <code>0</code> here, since the <code>0</code> tagset requires the receiving buffer to deal with with pasting of arbitrary tags. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagset_name</em>&nbsp;</td><td>An optional tagset name, on <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Gdk::Atom that corresponds to the newly registered format's mime-type.</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000365">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="2e0f4cce4c2313f57ec2f670e6e1143e"></a><!-- doxytag: member="Gtk::TextBuffer::remove_all_tags" ref="2e0f4cce4c2313f57ec2f670e6e1143e" args="(const iterator &amp;start, const iterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::remove_all_tags           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all tags in the range between <em>start</em> and <em>end</em>. 
<p>
Be careful with this function; it could remove tags added in code unrelated to the code you're currently writing. That is, using this function is probably a bad idea if you have two or more unrelated code sections that add tags. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of range to be untagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Other bound of range to be untagged. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ea3cb7a24ecfcbbda5d586aa2ffbba2d"></a><!-- doxytag: member="Gtk::TextBuffer::remove_selection_clipboard" ref="ea3cb7a24ecfcbbda5d586aa2ffbba2d" args="(const Glib::RefPtr&lt; Clipboard &gt; &amp;clipboard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::remove_selection_clipboard           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1Clipboard.html">Clipboard</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>clipboard</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a <a class="el" href="classGtk_1_1Clipboard.html" title="The Clipboard object represents a clipboard of data shared between different processes...">Gtk::Clipboard</a> added with <a class="el" href="classGtk_1_1TextBuffer.html#d9cecd4c6d2360985966f32cad5688a8" title="Adds clipboard to the list of clipboards in which the selection contents of buffer...">add_selection_clipboard()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clipboard</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1Clipboard.html" title="The Clipboard object represents a clipboard of data shared between different processes...">Gtk::Clipboard</a> added to <em>buffer</em> by <a class="el" href="classGtk_1_1TextBuffer.html#d9cecd4c6d2360985966f32cad5688a8" title="Adds clipboard to the list of clipboards in which the selection contents of buffer...">add_selection_clipboard()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29ca8940b626a3fa883abb791a52852b"></a><!-- doxytag: member="Gtk::TextBuffer::remove_tag" ref="29ca8940b626a3fa883abb791a52852b" args="(const Glib::RefPtr&lt; Tag &gt; &amp;tag, const iterator &amp;start, const iterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::remove_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">Tag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits the "remove-tag" signal. 
<p>
The default handler for the signal removes all occurrences of <em>tag</em> from the given range. <em>start</em> and <em>end</em> don't have to be in order. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of range to be untagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Other bound of range to be untagged. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cf0a04e90b58b7e9253bd5e3207254a0"></a><!-- doxytag: member="Gtk::TextBuffer::remove_tag_by_name" ref="cf0a04e90b58b7e9253bd5e3207254a0" args="(const Glib::ustring &amp;name, const iterator &amp;start, const iterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::remove_tag_by_name           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextTagTable.html#58f83d7b98cf4f496a88ef63e8969d6c" title="Look up a named tag.">Gtk::TextTagTable::lookup()</a> on the buffer's tag table to get a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, then calls <a class="el" href="classGtk_1_1TextBuffer.html#29ca8940b626a3fa883abb791a52852b" title="Emits the &quot;remove-tag&quot; signal.">remove_tag()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>One bound of range to be untagged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Other bound of range to be untagged. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="88b0a4096add7e8ea77098ffa5973a7f"></a><!-- doxytag: member="Gtk::TextBuffer::select_range" ref="88b0a4096add7e8ea77098ffa5973a7f" args="(const iterator &amp;ins, const iterator &amp;bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::select_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">iterator</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>bound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function moves the "insert" and "selection_bound" marks simultaneously. 
<p>
If you move them in two steps with <a class="el" href="classGtk_1_1TextBuffer.html#82c1011da5758549e634729dcbc70839" title="Moves mark to the new location where.">move_mark()</a>, you will temporarily select a region in between their old and new locations, which can be pretty inefficient since the temporarily-selected region will force stuff to be recalculated. This function moves them as a unit, which can be optimized.<p>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000223">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ins</em>&nbsp;</td><td>Where to put the "insert" mark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound</em>&nbsp;</td><td>Where to put the "selection_bound" mark. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5b20c61b684f6924b2e97d07cddc9549"></a><!-- doxytag: member="Gtk::TextBuffer::set_can_create_tags" ref="5b20c61b684f6924b2e97d07cddc9549" args="(const Glib::ustring &amp;format, bool can_create_tags=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::set_can_create_tags           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_create_tags</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use this function to allow a rich text deserialization function to create new tags in the receiving buffer. 
<p>
Note that using this function is almost always a bad idea, because the rich text functions you register should know how to map the rich text format they handler to your text buffers set of tags.<p>
The ability of creating new (arbitrary!) tags in the receiving buffer is meant for special rich text formats like the internal one that is registered using <a class="el" href="classGtk_1_1TextBuffer.html#96727ba3da11bfbfbfac1bb23d34f2b4" title="This function registers GTK+&#39;s internal rich text serialization format with the...">register_deserialize_tagset()</a>, because that format is essentially a dump of the internal structure of the source buffer, including its tag names.<p>
You should allow creation of tags only if you know what you are doing, e.g. if you defined a tagset name for your application suite's text buffers and you know that it's fine to receive new tags from these buffers, because you know that your application can handle the newly created tags.<p>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000369">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>A Gdk::Atom representing a registered rich text format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>can_create_tags</em>&nbsp;</td><td>Whether deserializing this format may create tags. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ca1d54bd5b4497881b11f6c313ac3112"></a><!-- doxytag: member="Gtk::TextBuffer::set_modified" ref="ca1d54bd5b4497881b11f6c313ac3112" args="(bool setting=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::set_modified           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>setting</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to keep track of whether the buffer has been modified since the last time it was saved. 
<p>
Whenever the buffer is saved to disk, call gtk_text_buffer_set_modified ( <em>buffer</em>, <code>false</code>). When the buffer is modified, it will automatically toggled on the modified bit again. When the modified bit flips, the buffer emits a "modified-changed" signal. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setting</em>&nbsp;</td><td>Modification flag setting. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="67c274bcdd8500d4eaf1b1d543987b0f"></a><!-- doxytag: member="Gtk::TextBuffer::set_text" ref="67c274bcdd8500d4eaf1b1d543987b0f" args="(const char *text_begin, const char *text_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::set_text           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the current contents of the buffer, and inserts <em>text</em> instead. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text_begin</em>&nbsp;</td><td>The start of a UTF8 character array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text_end</em>&nbsp;</td><td>The end of the UTF8 character array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9dc48965b1949bb54c7297e6bd1d1248"></a><!-- doxytag: member="Gtk::TextBuffer::set_text" ref="9dc48965b1949bb54c7297e6bd1d1248" args="(const Glib::ustring &amp;text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::set_text           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the current contents of the buffer, and inserts <em>text</em> instead. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to put in the buffer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9521321e0afc85964363806b0d161e7e"></a><!-- doxytag: member="Gtk::TextBuffer::signal_apply_tag" ref="9521321e0afc85964363806b0d161e7e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy3&lt;void,const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp;,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&gt; Gtk::TextBuffer::signal_apply_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_apply_tag(const Glib::RefPtr&lt;TextBuffer::Tag&gt;&amp; tag, const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; range_end)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5d34c63ae4058694f3c7ed3d7da94a3"></a><!-- doxytag: member="Gtk::TextBuffer::signal_begin_user_action" ref="f5d34c63ae4058694f3c7ed3d7da94a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy0&lt; void &gt; Gtk::TextBuffer::signal_begin_user_action           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_begin_user_action()</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="96d7ede78d4b2548a49e9d440957490e"></a><!-- doxytag: member="Gtk::TextBuffer::signal_changed" ref="96d7ede78d4b2548a49e9d440957490e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy0&lt; void &gt; Gtk::TextBuffer::signal_changed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_changed()</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6aa45ed04cdbbf9b27047b7437fb5da6"></a><!-- doxytag: member="Gtk::TextBuffer::signal_end_user_action" ref="6aa45ed04cdbbf9b27047b7437fb5da6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy0&lt; void &gt; Gtk::TextBuffer::signal_end_user_action           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_end_user_action()</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="264464f6eecd25b6e8b12a41f66dd9f6"></a><!-- doxytag: member="Gtk::TextBuffer::signal_erase" ref="264464f6eecd25b6e8b12a41f66dd9f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy2&lt;void,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&gt; Gtk::TextBuffer::signal_erase           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The delete_range signal is emitted to delete a range from a <a class="el" href="classGtk_1_1TextBuffer.html" title="Multi-line attributed text that can be displayed by one or more Gtk::TextView widgets...">TextBuffer</a>. 
<p>
Note that your handler must not invalidate the <em>start</em> and <em>end</em> iters (or has to revalidate them), if it runs before the default handler. There is no need to keep the iters valid in handlers which run after the default handler but those don't have access to the deleted text.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>the start of the range to be deleted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>the end of the range to be deleted.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_erase(const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; start, const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; end)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e98f2ac411b877d418023bd9c2b0e03a"></a><!-- doxytag: member="Gtk::TextBuffer::signal_insert" ref="e98f2ac411b877d418023bd9c2b0e03a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy3&lt;void,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;,const Glib::ustring&amp;,int&gt; Gtk::TextBuffer::signal_insert           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_insert(const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; pos, const Glib::ustring&amp; text, int bytes)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d34d70a01ba8d0d36462c61d5fa3f0c"></a><!-- doxytag: member="Gtk::TextBuffer::signal_insert_child_anchor" ref="6d34d70a01ba8d0d36462c61d5fa3f0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy2&lt;void,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;,const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">ChildAnchor</a>&gt;&amp;&gt; Gtk::TextBuffer::signal_insert_child_anchor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_insert_child_anchor(const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; pos, const Glib::RefPtr&lt;ChildAnchor&gt;&amp; anchor)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9115beeba329a84f79931a343b0e030b"></a><!-- doxytag: member="Gtk::TextBuffer::signal_insert_pixbuf" ref="9115beeba329a84f79931a343b0e030b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy2&lt;void,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;,const Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&amp;&gt; Gtk::TextBuffer::signal_insert_pixbuf           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_insert_pixbuf(const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; pos, const Glib::RefPtr&lt;Gdk::Pixbuf&gt;&amp; pixbuf)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="12f425e88f67b48350a7b66590308d29"></a><!-- doxytag: member="Gtk::TextBuffer::signal_mark_deleted" ref="12f425e88f67b48350a7b66590308d29" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy1&lt;void,const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp;&gt; Gtk::TextBuffer::signal_mark_deleted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_mark_deleted(const Glib::RefPtr&lt;TextBuffer::Mark&gt;&amp; mark)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8f54fe724af4c50ba390896a24e46db"></a><!-- doxytag: member="Gtk::TextBuffer::signal_mark_set" ref="b8f54fe724af4c50ba390896a24e46db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy2&lt;void,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;,const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextBuffer::Mark</a>&gt;&amp;&gt; Gtk::TextBuffer::signal_mark_set           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_mark_set(const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; location, const Glib::RefPtr&lt;TextBuffer::Mark&gt;&amp; mark)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b51efdc6d4d18d180946b818c9078411"></a><!-- doxytag: member="Gtk::TextBuffer::signal_modified_changed" ref="b51efdc6d4d18d180946b818c9078411" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy0&lt; void &gt; Gtk::TextBuffer::signal_modified_changed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_modified_changed()</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e50591d26083eea8775c7f836ba9db4"></a><!-- doxytag: member="Gtk::TextBuffer::signal_remove_tag" ref="0e50591d26083eea8775c7f836ba9db4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy3&lt;void,const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextBuffer::Tag</a>&gt;&amp;,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;,const <a class="el" href="classGtk_1_1TextIter.html">TextBuffer::iterator</a>&amp;&gt; Gtk::TextBuffer::signal_remove_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Prototype:</b></dt><dd><code>void on_my_remove_tag(const Glib::RefPtr&lt;TextBuffer::Tag&gt;&amp; tag, const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; range_begin, const <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">TextBuffer::iterator</a>&amp; range_end)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0c1f34a82750596b1c8c3be2f7fa3f33"></a><!-- doxytag: member="Gtk::TextBuffer::size" ref="0c1f34a82750596b1c8c3be2f7fa3f33" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextBuffer::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See <a class="el" href="classGtk_1_1TextBuffer.html#da488c738d7311ea9cedacede3b3b03c" title="Gets the number of characters in the buffer; note that characters and bytes are not...">get_char_count()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="8b997d023e5072ed65efbc372ce38749"></a><!-- doxytag: member="Gtk::TextBuffer::unregister_deserialize_format" ref="8b997d023e5072ed65efbc372ce38749" args="(const Glib::ustring &amp;format)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::unregister_deserialize_format           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>format</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function unregisters a rich text format that was previously registered using register_deserialize_format() or <a class="el" href="classGtk_1_1TextBuffer.html#96727ba3da11bfbfbfac1bb23d34f2b4" title="This function registers GTK+&#39;s internal rich text serialization format with the...">register_deserialize_tagset()</a>. 
<p>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000368">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>A Gdk::Atom representing a registered rich text format. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4dfa38c996b5eb11478a8b53e0ab8917"></a><!-- doxytag: member="Gtk::TextBuffer::unregister_serialize_format" ref="4dfa38c996b5eb11478a8b53e0ab8917" args="(const Glib::ustring &amp;format)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextBuffer::unregister_serialize_format           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>format</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function unregisters a rich text format that was previously registered using register_serialize_format() or <a class="el" href="classGtk_1_1TextBuffer.html#a839b9811cc4c29f6ca1d72506bdd25e" title="This function registers GTK+&#39;s internal rich text serialization format with the...">register_serialize_tagset()</a>. 
<p>
<dl compact><dt><b><a class="el" href="newin2p10s.html#_newin2p10s000367">Since gtkmm 2.10:</a></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>A Gdk::Atom representing a registered rich text format. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="09788574b3f8d6503daf01070b33c853"></a><!-- doxytag: member="Gtk::TextBuffer::wrap" ref="09788574b3f8d6503daf01070b33c853" args="(GtkTextBuffer *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">Gtk::TextBuffer</a>&gt; wrap           </td>
          <td>(</td>
          <td class="paramtype">GtkTextBuffer *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A Glib::wrap() method for this object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&nbsp;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="textbuffer_8h.html">textbuffer.h</a></ul>
</div>
</div>
<!-- end main content -->

<hr><address><small>
Generated for gtkmm 2.4 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.8 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
