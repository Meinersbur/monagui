<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gtkmm 2.4: Gtk::TextIter Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/gtkmm_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="http://www.gtkmm.org/documentation.shtml">Main Page</a> &nbsp;
  <a href="group__Widgets.html">Widgets</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
  <a href="../../tutorial/html/index.html"> Book</a> &nbsp;
</center>
<hr width="100%"/>
<!-- begin main content -->
<div id="content">
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespaceGtk.html">Gtk</a>::<a class="el" href="classGtk_1_1TextIter.html">TextIter</a>
  </div>
<div class="contents">
<h1>Gtk::TextIter Class Reference<br>
<small>
[<a class="el" href="group__TextView.html">TextView Classes</a>]</small>
</h1><!-- doxytag: class="Gtk::TextIter" -->Typefed as <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">Gtk::TextBuffer::iterator</a>.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classGtk_1_1TextIter-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#1d32cb4ee3ea8790352a473954ddbbd4">difference_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br class="typebreak">
std::bidirectional_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#3a01330bff36d513299c97cd3e877181">iterator_category</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#42c43f99b310aee6c53adbd6dd71fe51">pointer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classGtk_1_1TextIter.html#e1f6efe5a5875e7198e3de43c64e2db0">value_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a0c83319eb101749fe43d587a0db45da">reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef gunichar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#e1f6efe5a5875e7198e3de43c64e2db0">value_type</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#eff64dab2ff97e06452f4ca7c030b758">backward_char</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves backward by one character offset.  <a href="#eff64dab2ff97e06452f4ca7c030b758"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#4020a5193148a459dcf24bb2bc829870">backward_chars</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>count</em> characters backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#4020a5193148a459dcf24bb2bc829870"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#c8a84e76bdbf9c60b214c964a47907d0">backward_cursor_position</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a>, but moves backward.  <a href="#c8a84e76bdbf9c60b214c964a47907d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#06cd242a69337fdbd712dfa784f2d494">backward_cursor_positions</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves up to <em>count</em> cursor positions.  <a href="#06cd242a69337fdbd712dfa784f2d494"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#7426256ea8ef836a507f5b2b85f7ec36">backward_find_char</a> (const Predicate&amp; predicate)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ef34c49b64ffeb38094e42807279cc7f">backward_find_char</a> (const Predicate&amp; predicate, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; limit)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#695ab83b6fbffa39496959a4f9a5eece">backward_line</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> to the start of the previous line.  <a href="#695ab83b6fbffa39496959a4f9a5eece"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#8a9e763fe2fd18f11a4156820f39bb9b">backward_lines</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>count</em> lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#8a9e763fe2fd18f11a4156820f39bb9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ea0239e99764c15e789cfe3b0d871676">backward_search</a> (const Glib::ustring&amp; str, <a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classGtk_1_1TextIter.html#0750fba2d45f6ed4a314340b2b522019" title="Same as forward_search(), but moves backward.">backward_search()</a>, but searches to the start.  <a href="#ea0239e99764c15e789cfe3b0d871676"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#0750fba2d45f6ed4a314340b2b522019">backward_search</a> (const Glib::ustring&amp; str, <a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_end, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; limit) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classGtk_1_1TextIter.html#e74bf1b660263296292752cb2795bea3" title="Searches forward for str.">forward_search()</a>, but moves backward.  <a href="#0750fba2d45f6ed4a314340b2b522019"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#7e0855474df38a9084db2cec9171140a">backward_sentence_start</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves backward to the previous sentence start; if <em>iter</em> is already at the start of a sentence, moves backward to the next one.  <a href="#7e0855474df38a9084db2cec9171140a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#86618c5b23bebc739057651aded7751a">backward_sentence_starts</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIter.html#7e0855474df38a9084db2cec9171140a" title="Moves backward to the previous sentence start; if iter is already at the start of...">backward_sentence_start()</a> up to <em>count</em> times, or until it returns <code>false</code>.  <a href="#86618c5b23bebc739057651aded7751a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#d17e2abaf014a0796ad7c668ca378d58">backward_to_tag_toggle</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp; tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves backward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>0</code>.  <a href="#d17e2abaf014a0796ad7c668ca378d58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#3ff24ef7f2c58692eb320365cd0d8001">backward_visible_cursor_position</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> forward to the previous visible cursor position.  <a href="#3ff24ef7f2c58692eb320365cd0d8001"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#455e4560fbd1fa19a6f8caea4348255f">backward_visible_cursor_positions</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves up to <em>count</em> visible cursor positions.  <a href="#455e4560fbd1fa19a6f8caea4348255f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#2d52ce38268847ed46cefca328b478cd">backward_visible_line</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> to the start of the previous visible line.  <a href="#2d52ce38268847ed46cefca328b478cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#435bac2e52fac10cbd4c5175fcc6893c">backward_visible_lines</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>count</em> visible lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#435bac2e52fac10cbd4c5175fcc6893c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#9e1afad7efe043ebf9f8c8a0aa6b8034">backward_visible_word_start</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves backward to the previous visible word start.  <a href="#9e1afad7efe043ebf9f8c8a0aa6b8034"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#432ef8da68c876335cb020e24b5880d4">backward_visible_word_starts</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIter.html#9e1afad7efe043ebf9f8c8a0aa6b8034" title="Moves backward to the previous visible word start.">backward_visible_word_start()</a> up to <em>count</em> times.  <a href="#432ef8da68c876335cb020e24b5880d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#8f8136c917007d6a4a7c7969221410d2">backward_word_start</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves backward to the previous word start.  <a href="#8f8136c917007d6a4a7c7969221410d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#14f5b1eeec69bdd6443b75a659407dd8">backward_word_starts</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIter.html#8f8136c917007d6a4a7c7969221410d2" title="Moves backward to the previous word start.">backward_word_start()</a> up to <em>count</em> times.  <a href="#14f5b1eeec69bdd6443b75a659407dd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#7b25da844d333a260e981c102a7939c6">begins_tag</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#fa90f81adb24aa2a32696aad22f78c46">begins_tag</a> (const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp; tag) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> is the start of a range tagged with <em>tag</em>.  <a href="#fa90f81adb24aa2a32696aad22f78c46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#88367b98344313923362b9234ed14f32">can_insert</a> (bool default_editability=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at <em>iter</em> would be editable.  <a href="#88367b98344313923362b9234ed14f32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#179ef78b967ddcd1b2b5bc04a883785c">compare</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A qsort()-style function that returns negative if <em>lhs</em> is less than <em>rhs</em>, positive if <em>lhs</em> is greater than <em>rhs</em>, and 0 if they're equal.  <a href="#179ef78b967ddcd1b2b5bc04a883785c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#3d633d1507cd563706b06e7411486e07">editable</a> (bool default_setting=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> is inside an editable range.  <a href="#3d633d1507cd563706b06e7411486e07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aa5015190ea3032cc5afd1b580e58643">ends_line</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> is at the end of a line.  <a href="#aa5015190ea3032cc5afd1b580e58643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#3cfe850637d87bab19eeedce768461f9">ends_sentence</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <em>iter</em> ends a sentence.  <a href="#3cfe850637d87bab19eeedce768461f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#9cbd50e0caf2f3c4d56af8d3f619b3a6">ends_tag</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#69904722c3b9e761eae2aba31d5a88d5">ends_tag</a> (const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp; tag) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> is the end of a range tagged with <em>tag</em>.  <a href="#69904722c3b9e761eae2aba31d5a88d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#89cf1e2a86328328fdbd63efc1f477be">ends_word</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <em>iter</em> ends a natural-language word.  <a href="#89cf1e2a86328328fdbd63efc1f477be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#46acea844c69273d92c63d910eca21c9">forward_char</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> forward by one character offset.  <a href="#46acea844c69273d92c63d910eca21c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#adbab55d587698d0f51776faa0cc2a43">forward_chars</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>count</em> characters if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#adbab55d587698d0f51776faa0cc2a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684">forward_cursor_position</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> forward by a single cursor position.  <a href="#c43e1833c36390271f139096f2246684"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#8b20683d7513dfb331bb0a1aeffa63c5">forward_cursor_positions</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves up to <em>count</em> cursor positions.  <a href="#8b20683d7513dfb331bb0a1aeffa63c5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#1dd44d882c6ce3b85408712d3296c124">forward_find_char</a> (const Predicate&amp; predicate)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#3103d609ff2e2a08a2297141dff0fee4">forward_find_char</a> (const Predicate&amp; predicate, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; limit)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ca8832f0168bbcf8651cff1eb632f13f">forward_line</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> to the start of the next line.  <a href="#ca8832f0168bbcf8651cff1eb632f13f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#db054a9ee7862010ad5564571bda2552">forward_lines</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>count</em> lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#db054a9ee7862010ad5564571bda2552"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#dfa8920e9c706937136f4d2cdb75b83c">forward_search</a> (const Glib::ustring&amp; str, <a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classGtk_1_1TextIter.html#e74bf1b660263296292752cb2795bea3" title="Searches forward for str.">forward_search()</a>, but searchs to the end.  <a href="#dfa8920e9c706937136f4d2cdb75b83c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#e74bf1b660263296292752cb2795bea3">forward_search</a> (const Glib::ustring&amp; str, <a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; match_end, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; limit) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches forward for <em>str</em>.  <a href="#e74bf1b660263296292752cb2795bea3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#2d1c3dc0fa3c7545e6a09aa082e4032e">forward_sentence_end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves forward to the next sentence end.  <a href="#2d1c3dc0fa3c7545e6a09aa082e4032e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#6aef31e21147f939af5f34ef930f16bf">forward_sentence_ends</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIter.html#2d1c3dc0fa3c7545e6a09aa082e4032e" title="Moves forward to the next sentence end.">forward_sentence_end()</a> <em>count</em> times (or until <a class="el" href="classGtk_1_1TextIter.html#2d1c3dc0fa3c7545e6a09aa082e4032e" title="Moves forward to the next sentence end.">forward_sentence_end()</a> returns <code>false</code>).  <a href="#6aef31e21147f939af5f34ef930f16bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#70abfc30933f0e8dec3f014128443dc4">forward_to_end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> forward to the "end iterator," which points one past the last valid character in the buffer.  <a href="#70abfc30933f0e8dec3f014128443dc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#31f8195cab1810e35b88122d2ebd7b90">forward_to_line_end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character.  <a href="#31f8195cab1810e35b88122d2ebd7b90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#89b4fc66df6e0b9b8046c2f70b261629">forward_to_tag_toggle</a> (const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp; tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves forward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>0</code>.  <a href="#89b4fc66df6e0b9b8046c2f70b261629"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#647f1e0b30b3ad9470d67f8d42108d6a">forward_visible_cursor_position</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> forward to the next visible cursor position.  <a href="#647f1e0b30b3ad9470d67f8d42108d6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#770ab9cd1f2dd86d586567cb19f8d9a4">forward_visible_cursor_positions</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves up to <em>count</em> visible cursor positions.  <a href="#770ab9cd1f2dd86d586567cb19f8d9a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#55a295c7dead80d24470f33a67a6dd74">forward_visible_line</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>count</em> visible lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="#55a295c7dead80d24470f33a67a6dd74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#506be5cb9d7dd29522b71cddd520bda3">forward_visible_line</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> to the start of the next visible line.  <a href="#506be5cb9d7dd29522b71cddd520bda3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#c79bd3e6c8cd7ccdc45b8ed8064986e8">forward_visible_word_end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves forward to the next visible word end.  <a href="#c79bd3e6c8cd7ccdc45b8ed8064986e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#d9a7521c3392d07d24790702433cd1ff">forward_visible_word_ends</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIter.html#c79bd3e6c8cd7ccdc45b8ed8064986e8" title="Moves forward to the next visible word end.">forward_visible_word_end()</a> up to <em>count</em> times.  <a href="#d9a7521c3392d07d24790702433cd1ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#05bba655ab512cf1569590d9206d797b">forward_word_end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves forward to the next word end.  <a href="#05bba655ab512cf1569590d9206d797b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a7d74cb53546701ec0b42266ac40e2a1">forward_word_ends</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIter.html#05bba655ab512cf1569590d9206d797b" title="Moves forward to the next word end.">forward_word_end()</a> up to <em>count</em> times.  <a href="#a7d74cb53546701ec0b42266ac40e2a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#b83601605d0226595e4f36477bc666ce">get_attributes</a> (<a class="el" href="classGtk_1_1TextAttributes.html">TextAttributes</a>&amp; values) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#f2244ebff821e640cd163779711d96a8">get_buffer</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: the buffer.  <a href="#f2244ebff821e640cd163779711d96a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#66ae8164fd98bc8552956138800fb547">get_bytes_in_line</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: number of bytes in the line.  <a href="#66ae8164fd98bc8552956138800fb547"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gunichar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#63cd8afd6fb53bdedef424b42bbc66b7">get_char</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns 0.  <a href="#63cd8afd6fb53bdedef424b42bbc66b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#fecdd3d4363598c3cc5058965d0dac2b">get_chars_in_line</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: number of characters in the line.  <a href="#fecdd3d4363598c3cc5058965d0dac2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt; const <br class="typebreak">
<a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#682ce9b6067548ab103cd3f64867b986">get_child_anchor</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the location at <em>iter</em> contains a child anchor, the anchor is returned (with no new reference count added).  <a href="#682ce9b6067548ab103cd3f64867b986"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#b8ee402bb518aeed4aeef15f29710cb4">get_child_anchor</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the location at <em>iter</em> contains a child anchor, the anchor is returned (with no new reference count added).  <a href="#b8ee402bb518aeed4aeef15f29710cb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/classPango_1_1Language.html">Pango::Language</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#f47c3ce2b5a03bae097c878c07b5daec">get_language</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper around <a class="el" href="classGtk_1_1TextIter.html#b83601605d0226595e4f36477bc666ce">get_attributes()</a>, which returns the language in effect at <em>iter</em>.  <a href="#f47c3ce2b5a03bae097c878c07b5daec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#e51ca638396eb61fd1997b6c1538f0c7">get_line</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: a line number.  <a href="#e51ca638396eb61fd1997b6c1538f0c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#4a0c83b81f49e182c60e7f7c40fad8f8">get_line_index</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: distance from start of line, in bytes.  <a href="#4a0c83b81f49e182c60e7f7c40fad8f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#93ea3d3cfcc39f69555545b4bdd38530">get_line_offset</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: offset from start of line.  <a href="#93ea3d3cfcc39f69555545b4bdd38530"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SListHandle<br class="typebreak">
&lt;Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextMark.html">TextMark</a>&gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#816e1c24bb5462aec8d4d540044a6239">get_marks</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: list of <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>.  <a href="#816e1c24bb5462aec8d4d540044a6239"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SListHandle<br class="typebreak">
&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextMark</a>&gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a6dc67578010ba3d16375d3fd3810ee0">get_marks</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: list of <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>.  <a href="#a6dc67578010ba3d16375d3fd3810ee0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#23db9e028b016cda6fd3af40fb3ef1af">get_offset</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: a character offset.  <a href="#23db9e028b016cda6fd3af40fb3ef1af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#c4813d198441c620d2afbec63be45ccc">get_pixbuf</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the element at <em>iter</em> is a pixbuf, the pixbuf is returned (with no new reference count added).  <a href="#c4813d198441c620d2afbec63be45ccc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#cbf2a271e33232170e1c41ccb1aa12e1">get_slice</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: slice of text from the buffer.  <a href="#cbf2a271e33232170e1c41ccb1aa12e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SListHandle<br class="typebreak">
&lt;Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#749b813bb4c369bff9e04e6f79d487aa">get_tags</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of tags that apply to <em>iter</em>, in ascending order of priority (highest-priority tags are last).  <a href="#749b813bb4c369bff9e04e6f79d487aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SListHandle<br class="typebreak">
&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#e7bb7f1d6de6949cb995d316307ec0bb">get_tags</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of tags that apply to <em>iter</em>, in ascending order of priority (highest-priority tags are last).  <a href="#e7bb7f1d6de6949cb995d316307ec0bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#68fceee86d4913529a918872438cff8a">get_text</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: array of characters from the buffer.  <a href="#68fceee86d4913529a918872438cff8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SListHandle<br class="typebreak">
&lt;Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#eca8604e9583471ca6b76ab14bb1030a">get_toggled_tags</a> (bool toggled_on=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: tags toggled at this point.  <a href="#eca8604e9583471ca6b76ab14bb1030a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::SListHandle<br class="typebreak">
&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#f320581d5694946f227130116909c27f">get_toggled_tags</a> (bool toggled_on=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: tags toggled at this point.  <a href="#f320581d5694946f227130116909c27f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#726f03533f659eba9d58cdcb7e3752ae">get_visible_line_index</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: byte index of <em>iter</em> with respect to the start of the line.  <a href="#726f03533f659eba9d58cdcb7e3752ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ff8216613df48ec3ec109ef60e7dbdb2">get_visible_line_offset</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: offset in visible characters from the start of the line.  <a href="#ff8216613df48ec3ec109ef60e7dbdb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#0972fc9b1892e9199c60779634c5bde5">get_visible_slice</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIter.html#cbf2a271e33232170e1c41ccb1aa12e1" title="Return value: slice of text from the buffer.">get_slice()</a>, but invisible text is not included.  <a href="#0972fc9b1892e9199c60779634c5bde5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Glib::ustring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#15ec6157320b54c7b16952e2005e106b">get_visible_text</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIter.html#68fceee86d4913529a918872438cff8a" title="Return value: array of characters from the buffer.">get_text()</a>, but invisible text is not included.  <a href="#15ec6157320b54c7b16952e2005e106b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const GtkTextIter*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#050314ca046487d60c14a13085d0b0a3">gobj</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C instance.  <a href="#050314ca046487d60c14a13085d0b0a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GtkTextIter*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#c5fe90901048c857a70fdcf6bfc83e5d">gobj</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C instance.  <a href="#c5fe90901048c857a70fdcf6bfc83e5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#b6bc228450c06a466e28717da8e8d1b5">has_tag</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#3f3c8fbd79f6f8bd50e3831ee4661a96">has_tag</a> (const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp; tag) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> is tagged with <em>tag</em>.  <a href="#3f3c8fbd79f6f8bd50e3831ee4661a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#b537dff76037393f0abec24859561f3c">in_range</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; start, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether <em>iter</em> falls in the range [ <em>start</em>, <em>end</em>).  <a href="#b537dff76037393f0abec24859561f3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#29ff52b7b859a529ce8036615a7ea11b">inside_sentence</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <em>iter</em> is inside a sentence (as opposed to in between two sentences, e.g. after a period and before the first letter of the next sentence).  <a href="#29ff52b7b859a529ce8036615a7ea11b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#63e3578d35cf55bf9ca33bfcac6cf716">inside_word</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <em>iter</em> is inside a natural-language word (as opposed to say inside some whitespace).  <a href="#63e3578d35cf55bf9ca33bfcac6cf716"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#6f1cce58629dbc6058576dff992cded0">is_cursor_position</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a> or <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html#b0b3468a9efcaec7022885d46fd43d09">Pango::LogAttr</a> or pango_break() for details on what a cursor position is.  <a href="#6f1cce58629dbc6058576dff992cded0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#87078ad316a037bdd04a40d85145be3e">is_end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> is the end iterator.  <a href="#87078ad316a037bdd04a40d85145be3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#218044fcce516c2982b2e54225619b93">is_start</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> is the first in the buffer.  <a href="#218044fcce516c2982b2e54225619b93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#6d5012897961552a524589378af6c17f">operator bool</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for !is_end().  <a href="#6d5012897961552a524589378af6c17f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html#e1f6efe5a5875e7198e3de43c64e2db0">value_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#25bc72debbe24fa32719261d591949e7">operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for <a class="el" href="classGtk_1_1TextIter.html#63cd8afd6fb53bdedef424b42bbc66b7" title="returns 0.">get_char()</a>.  <a href="#25bc72debbe24fa32719261d591949e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#e27c3a2f0663071f9319fe140f047b72">operator++</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#11ef1de054169a9ca48cca88d03ad04e">operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for <a class="el" href="classGtk_1_1TextIter.html#46acea844c69273d92c63d910eca21c9" title="Moves iter forward by one character offset.">forward_char()</a>.  <a href="#11ef1de054169a9ca48cca88d03ad04e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#e9050a524dda968db856b3e791fc833d">operator--</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#d1fea62e0f049dac87497aadc4e32ac2">operator--</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for <a class="el" href="classGtk_1_1TextIter.html#eff64dab2ff97e06452f4ca7c030b758" title="Moves backward by one character offset.">backward_char()</a>.  <a href="#d1fea62e0f049dac87497aadc4e32ac2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#4d3c25edf1efe92f5313ac740781238b">order</a> (<a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; second)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the value of <em>first</em> and <em>second</em> if <em>second</em> comes before <em>first</em> in the buffer.  <a href="#4d3c25edf1efe92f5313ac740781238b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#bfba7a50f3ec781d151cc5643e1b4083">set_line</a> (int line_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves iterator <em>iter</em> to the start of the line <em>line_number</em>.  <a href="#bfba7a50f3ec781d151cc5643e1b4083"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#f63b8c2520413efdde54dd8ad5670579">set_line_index</a> (int byte_on_line)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classGtk_1_1TextIter.html#62c90b4327191537170c796a23d06b25" title="Moves iter within a line, to a new character (not byte) offset.">set_line_offset()</a>, but works with a <em>byte</em> index.  <a href="#f63b8c2520413efdde54dd8ad5670579"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#62c90b4327191537170c796a23d06b25">set_line_offset</a> (int char_on_line)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves <em>iter</em> within a line, to a new <em>character</em> (not byte) offset.  <a href="#62c90b4327191537170c796a23d06b25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#00ce173ce4d3622cc36e48d5bff2374f">set_offset</a> (int char_offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets <em>iter</em> to point to <em>char_offset</em>.  <a href="#00ce173ce4d3622cc36e48d5bff2374f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#40b3039e099a9c3d752b8a3809d1ae4d">set_visible_line_index</a> (int byte_on_line)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIter.html#f63b8c2520413efdde54dd8ad5670579" title="Same as set_line_offset(), but works with a byte index.">set_line_index()</a>, but the index is in visible bytes, i.e. text with a tag making it invisible is not counted in the index.  <a href="#40b3039e099a9c3d752b8a3809d1ae4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#7ccd69e5353e073ce841ff0e02ac6a7e">set_visible_line_offset</a> (int char_on_line)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIter.html#62c90b4327191537170c796a23d06b25" title="Moves iter within a line, to a new character (not byte) offset.">set_line_offset()</a>, but the offset is in visible characters, i.e. text with a tag making it invisible is not counted in the offset.  <a href="#7ccd69e5353e073ce841ff0e02ac6a7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#3af99cb623ef41f2c1ec23e87a27b31a">starts_line</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value: whether <em>iter</em> begins a line.  <a href="#3af99cb623ef41f2c1ec23e87a27b31a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#5e3ea3c5bcb8aa11ecaeea2be490323b">starts_sentence</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <em>iter</em> begins a sentence.  <a href="#5e3ea3c5bcb8aa11ecaeea2be490323b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#727ff792013d3b9d1b2c28ed4b2af514">starts_word</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <em>iter</em> begins a natural-language word.  <a href="#727ff792013d3b9d1b2c28ed4b2af514"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#c015411ec402d42fe22dfa048a97d7b2">TextIter</a> (const GtkTextIter* gobject)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#311d1ed5fa8bd0d55d18b743d45bd118">TextIter</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#e9932c4003339e1f294ebd33dec309ed">toggles_tag</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#1b8a333956be379051b987521f383c1b">toggles_tag</a> (const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp; tag) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is equivalent to (<a class="el" href="classGtk_1_1TextIter.html#fa90f81adb24aa2a32696aad22f78c46" title="Return value: whether iter is the start of a range tagged with tag.">begins_tag()</a> || <a class="el" href="classGtk_1_1TextIter.html#69904722c3b9e761eae2aba31d5a88d5" title="Return value: whether iter is the end of a range tagged with tag.">ends_tag()</a>), i.e. it tells you whether a range with <em>tag</em> applied to it begins <em>or</em> ends at <em>iter</em>.  <a href="#1b8a333956be379051b987521f383c1b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GtkTextIter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#533d80230ee6366bc575bed7369f4afb">gobject_</a></td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#0e373b53b974fbab36b1d45ebd206c76">operator!=</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#1cdd13320f231bd906520131cdc138d2">operator&lt;</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#76f0b1315ba7b06bbdfbdd2e029bda73">operator&lt;=</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#8703a159b88dc5e8dd8d4ea361667281">operator==</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#d50c7c8990fac0c51ac460034ff5f3c4">operator&gt;</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#387ff6ec0c707b3a30ea7398cdc601d2">operator&gt;=</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a>&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#5d77ba6925f3144ad49e36412791b7aa">wrap</a> (const GtkTextIter* object)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a>&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#5497a6a3458131b32c6aaa0fcab3f511">wrap</a> (GtkTextIter* object)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Typefed as <a class="el" href="classGtk_1_1TextBuffer.html#bb8a8a5abd18b84218e12a4678dcc3c0">Gtk::TextBuffer::iterator</a>. 
<p>
An iterator represents a position between two characters in the text buffer. Iterators are not valid indefinitely; whenever the buffer is modified in a way that affects the number of characters in the buffer, all outstanding iterators become invalid. (Note that deleting 5 characters and then reinserting 5 still invalidates iterators, though you end up with the same number of characters you pass through a state with a different number).<p>
Because of this, iterators can't be used to preserve positions across buffer modifications. To preserve a position, the <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextBuffer::Mark</a> object is ideal.<p>
You can iterate over characters, words, lines, and sentences, but <a class="el" href="classGtk_1_1TextIter.html#25bc72debbe24fa32719261d591949e7" title="Alias for get_char().">operator*()</a> and <a class="el" href="classGtk_1_1TextIter.html#11ef1de054169a9ca48cca88d03ad04e" title="Alias for forward_char().">operator++()</a> deal only in characters. <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="1d32cb4ee3ea8790352a473954ddbbd4"></a><!-- doxytag: member="Gtk::TextIter::difference_type" ref="1d32cb4ee3ea8790352a473954ddbbd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classGtk_1_1TextIter.html#1d32cb4ee3ea8790352a473954ddbbd4">Gtk::TextIter::difference_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3a01330bff36d513299c97cd3e877181"></a><!-- doxytag: member="Gtk::TextIter::iterator_category" ref="3a01330bff36d513299c97cd3e877181" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::bidirectional_iterator_tag <a class="el" href="classGtk_1_1TextIter.html#3a01330bff36d513299c97cd3e877181">Gtk::TextIter::iterator_category</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="42c43f99b310aee6c53adbd6dd71fe51"></a><!-- doxytag: member="Gtk::TextIter::pointer" ref="42c43f99b310aee6c53adbd6dd71fe51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="classGtk_1_1TextIter.html#42c43f99b310aee6c53adbd6dd71fe51">Gtk::TextIter::pointer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a0c83319eb101749fe43d587a0db45da"></a><!-- doxytag: member="Gtk::TextIter::reference" ref="a0c83319eb101749fe43d587a0db45da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGtk_1_1TextIter.html#e1f6efe5a5875e7198e3de43c64e2db0">value_type</a> <a class="el" href="classGtk_1_1TextIter.html#a0c83319eb101749fe43d587a0db45da">Gtk::TextIter::reference</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e1f6efe5a5875e7198e3de43c64e2db0"></a><!-- doxytag: member="Gtk::TextIter::value_type" ref="e1f6efe5a5875e7198e3de43c64e2db0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gunichar <a class="el" href="classGtk_1_1TextIter.html#e1f6efe5a5875e7198e3de43c64e2db0">Gtk::TextIter::value_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="311d1ed5fa8bd0d55d18b743d45bd118"></a><!-- doxytag: member="Gtk::TextIter::TextIter" ref="311d1ed5fa8bd0d55d18b743d45bd118" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextIter::TextIter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c015411ec402d42fe22dfa048a97d7b2"></a><!-- doxytag: member="Gtk::TextIter::TextIter" ref="c015411ec402d42fe22dfa048a97d7b2" args="(const GtkTextIter *gobject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextIter::TextIter           </td>
          <td>(</td>
          <td class="paramtype">const GtkTextIter *&nbsp;</td>
          <td class="paramname"> <em>gobject</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="eff64dab2ff97e06452f4ca7c030b758"></a><!-- doxytag: member="Gtk::TextIter::backward_char" ref="eff64dab2ff97e06452f4ca7c030b758" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_char           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward by one character offset. 
<p>
Returns <code>true</code> if movement was possible; if <em>iter</em> was the first in the buffer (character offset 0), <a class="el" href="classGtk_1_1TextIter.html#eff64dab2ff97e06452f4ca7c030b758" title="Moves backward by one character offset.">backward_char()</a> returns <code>false</code> for convenience when writing loops. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether movement was possible. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4020a5193148a459dcf24bb2bc829870"></a><!-- doxytag: member="Gtk::TextIter::backward_chars" ref="4020a5193148a459dcf24bb2bc829870" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_chars           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> characters backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of characters to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c8a84e76bdbf9c60b214c964a47907d0"></a><!-- doxytag: member="Gtk::TextIter::backward_cursor_position" ref="c8a84e76bdbf9c60b214c964a47907d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a>, but moves backward. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved. </dd></dl>

</div>
</div><p>
<a class="anchor" name="06cd242a69337fdbd712dfa784f2d494"></a><!-- doxytag: member="Gtk::TextIter::backward_cursor_positions" ref="06cd242a69337fdbd712dfa784f2d494" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves up to <em>count</em> cursor positions. 
<p>
See <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7426256ea8ef836a507f5b2b85f7ec36"></a><!-- doxytag: member="Gtk::TextIter::backward_find_char" ref="7426256ea8ef836a507f5b2b85f7ec36" args="(const Predicate &amp;predicate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_find_char           </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ef34c49b64ffeb38094e42807279cc7f"></a><!-- doxytag: member="Gtk::TextIter::backward_find_char" ref="ef34c49b64ffeb38094e42807279cc7f" args="(const Predicate &amp;predicate, const TextIter &amp;limit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_find_char           </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="695ab83b6fbffa39496959a4f9a5eece"></a><!-- doxytag: member="Gtk::TextIter::backward_line" ref="695ab83b6fbffa39496959a4f9a5eece" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> to the start of the previous line. 
<p>
Returns <code>true</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>false</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>true</code>. (Note that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a9e763fe2fd18f11a4156820f39bb9b"></a><!-- doxytag: member="Gtk::TextIter::backward_lines" ref="8a9e763fe2fd18f11a4156820f39bb9b" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_lines           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of lines to move backward. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea0239e99764c15e789cfe3b0d871676"></a><!-- doxytag: member="Gtk::TextIter::backward_search" ref="ea0239e99764c15e789cfe3b0d871676" args="(const Glib::ustring &amp;str, TextSearchFlags flags, TextIter &amp;match_start, TextIter &amp;match_end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_search           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classGtk_1_1TextIter.html#0750fba2d45f6ed4a314340b2b522019" title="Same as forward_search(), but moves backward.">backward_search()</a>, but searches to the start. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Bitmask of flags affecting the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>Return location for start of match, or <code>0</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>Return location for end of match, or <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0750fba2d45f6ed4a314340b2b522019"></a><!-- doxytag: member="Gtk::TextIter::backward_search" ref="0750fba2d45f6ed4a314340b2b522019" args="(const Glib::ustring &amp;str, TextSearchFlags flags, TextIter &amp;match_start, TextIter &amp;match_end, const TextIter &amp;limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_search           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classGtk_1_1TextIter.html#e74bf1b660263296292752cb2795bea3" title="Searches forward for str.">forward_search()</a>, but moves backward. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Bitmask of flags affecting the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>Return location for start of match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>Return location for end of match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>Location of last possible <em>match_start</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e0855474df38a9084db2cec9171140a"></a><!-- doxytag: member="Gtk::TextIter::backward_sentence_start" ref="7e0855474df38a9084db2cec9171140a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_sentence_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the previous sentence start; if <em>iter</em> is already at the start of a sentence, moves backward to the next one. 
<p>
Sentence boundaries are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> text boundary algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="86618c5b23bebc739057651aded7751a"></a><!-- doxytag: member="Gtk::TextIter::backward_sentence_starts" ref="86618c5b23bebc739057651aded7751a" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_sentence_starts           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextIter.html#7e0855474df38a9084db2cec9171140a" title="Moves backward to the previous sentence start; if iter is already at the start of...">backward_sentence_start()</a> up to <em>count</em> times, or until it returns <code>false</code>. 
<p>
If <em>count</em> is negative, moves forward instead of backward. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of sentences to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d17e2abaf014a0796ad7c668ca378d58"></a><!-- doxytag: member="Gtk::TextIter::backward_to_tag_toggle" ref="d17e2abaf014a0796ad7c668ca378d58" args="(const Glib::RefPtr&lt; TextTag &gt; &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_to_tag_toggle           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>0</code>. 
<p>
If no matching tag toggles are found, Return value: whether we found a tag toggle before <em>iter</em> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether we found a tag toggle before <em>iter</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ff24ef7f2c58692eb320365cd0d8001"></a><!-- doxytag: member="Gtk::TextIter::backward_visible_cursor_position" ref="3ff24ef7f2c58692eb320365cd0d8001" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> forward to the previous visible cursor position. 
<p>
See <a class="el" href="classGtk_1_1TextIter.html#c8a84e76bdbf9c60b214c964a47907d0" title="Like forward_cursor_position(), but moves backward.">backward_cursor_position()</a> for details. <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new position is dereferenceable</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000229">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="455e4560fbd1fa19a6f8caea4348255f"></a><!-- doxytag: member="Gtk::TextIter::backward_visible_cursor_positions" ref="455e4560fbd1fa19a6f8caea4348255f" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves up to <em>count</em> visible cursor positions. 
<p>
See <a class="el" href="classGtk_1_1TextIter.html#c8a84e76bdbf9c60b214c964a47907d0" title="Like forward_cursor_position(), but moves backward.">backward_cursor_position()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new position is dereferenceable</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000231">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="2d52ce38268847ed46cefca328b478cd"></a><!-- doxytag: member="Gtk::TextIter::backward_visible_line" ref="2d52ce38268847ed46cefca328b478cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> to the start of the previous visible line. 
<p>
Returns <code>true</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>false</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>true</code>. (Note that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p8s.html#_newin2p8s000041">Since gtkmm 2.8:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="435bac2e52fac10cbd4c5175fcc6893c"></a><!-- doxytag: member="Gtk::TextIter::backward_visible_lines" ref="435bac2e52fac10cbd4c5175fcc6893c" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_lines           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> visible lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of lines to move backward. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved and is dereferenceable</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p8s.html#_newin2p8s000043">Since gtkmm 2.8:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="9e1afad7efe043ebf9f8c8a0aa6b8034"></a><!-- doxytag: member="Gtk::TextIter::backward_visible_word_start" ref="9e1afad7efe043ebf9f8c8a0aa6b8034" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_word_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the previous visible word start. 
<p>
(If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> word break algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000225">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="432ef8da68c876335cb020e24b5880d4"></a><!-- doxytag: member="Gtk::TextIter::backward_visible_word_starts" ref="432ef8da68c876335cb020e24b5880d4" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_word_starts           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextIter.html#9e1afad7efe043ebf9f8c8a0aa6b8034" title="Moves backward to the previous visible word start.">backward_visible_word_start()</a> up to <em>count</em> times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000227">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="8f8136c917007d6a4a7c7969221410d2"></a><!-- doxytag: member="Gtk::TextIter::backward_word_start" ref="8f8136c917007d6a4a7c7969221410d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_word_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves backward to the previous word start. 
<p>
(If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> word break algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="14f5b1eeec69bdd6443b75a659407dd8"></a><!-- doxytag: member="Gtk::TextIter::backward_word_starts" ref="14f5b1eeec69bdd6443b75a659407dd8" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_word_starts           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextIter.html#8f8136c917007d6a4a7c7969221410d2" title="Moves backward to the previous word start.">backward_word_start()</a> up to <em>count</em> times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b25da844d333a260e981c102a7939c6"></a><!-- doxytag: member="Gtk::TextIter::begins_tag" ref="7b25da844d333a260e981c102a7939c6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::begins_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fa90f81adb24aa2a32696aad22f78c46"></a><!-- doxytag: member="Gtk::TextIter::begins_tag" ref="fa90f81adb24aa2a32696aad22f78c46" args="(const Glib::RefPtr&lt; const TextTag &gt; &amp;tag) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::begins_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> is the start of a range tagged with <em>tag</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> is the start of a range tagged with <em>tag</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88367b98344313923362b9234ed14f32"></a><!-- doxytag: member="Gtk::TextIter::can_insert" ref="88367b98344313923362b9234ed14f32" args="(bool default_editability=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::can_insert           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_editability</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at <em>iter</em> would be editable. 
<p>
If text inserted at <em>iter</em> would be editable then the user should be allowed to insert text at <em>iter</em>. <a class="el" href="classGtk_1_1TextBuffer.html#5ae3a0c42cf66591c116dbb5ab3efd5f" title="Like insert(), but the insertion will not occur if iter is at a non-editable location...">Gtk::TextBuffer::insert_interactive()</a> uses this function to decide whether insertions are allowed at a given position. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>default_editability</em>&nbsp;</td><td><code>true</code> if text is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether text inserted at <em>iter</em> would be editable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="179ef78b967ddcd1b2b5bc04a883785c"></a><!-- doxytag: member="Gtk::TextIter::compare" ref="179ef78b967ddcd1b2b5bc04a883785c" args="(const TextIter &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::compare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A qsort()-style function that returns negative if <em>lhs</em> is less than <em>rhs</em>, positive if <em>lhs</em> is greater than <em>rhs</em>, and 0 if they're equal. 
<p>
Ordering is in character offset order, i.e. the first character in the buffer is less than the second character in the buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>Another <a class="el" href="classGtk_1_1TextIter.html" title="Typefed as Gtk::TextBuffer::iterator.">Gtk::TextIter</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if <em>lhs</em> is less than <em>rhs</em>, 1 if <em>lhs</em> is greater, 0 if they are equal. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d633d1507cd563706b06e7411486e07"></a><!-- doxytag: member="Gtk::TextIter::editable" ref="3d633d1507cd563706b06e7411486e07" args="(bool default_setting=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::editable           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_setting</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> is inside an editable range. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>default_setting</em>&nbsp;</td><td><code>true</code> if text is editable by default. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> is inside an editable range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa5015190ea3032cc5afd1b580e58643"></a><!-- doxytag: member="Gtk::TextIter::ends_line" ref="aa5015190ea3032cc5afd1b580e58643" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> is at the end of a line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> is at the end of a line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3cfe850637d87bab19eeedce768461f9"></a><!-- doxytag: member="Gtk::TextIter::ends_sentence" ref="3cfe850637d87bab19eeedce768461f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_sentence           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether <em>iter</em> ends a sentence. 
<p>
Sentence boundaries are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> text boundary algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> is at the end of a sentence. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cbd50e0caf2f3c4d56af8d3f619b3a6"></a><!-- doxytag: member="Gtk::TextIter::ends_tag" ref="9cbd50e0caf2f3c4d56af8d3f619b3a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="69904722c3b9e761eae2aba31d5a88d5"></a><!-- doxytag: member="Gtk::TextIter::ends_tag" ref="69904722c3b9e761eae2aba31d5a88d5" args="(const Glib::RefPtr&lt; const TextTag &gt; &amp;tag) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> is the end of a range tagged with <em>tag</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> is the end of a range tagged with <em>tag</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="89cf1e2a86328328fdbd63efc1f477be"></a><!-- doxytag: member="Gtk::TextIter::ends_word" ref="89cf1e2a86328328fdbd63efc1f477be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_word           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether <em>iter</em> ends a natural-language word. 
<p>
Word breaks are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> word break algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> is at the end of a word. </dd></dl>

</div>
</div><p>
<a class="anchor" name="46acea844c69273d92c63d910eca21c9"></a><!-- doxytag: member="Gtk::TextIter::forward_char" ref="46acea844c69273d92c63d910eca21c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_char           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> forward by one character offset. 
<p>
Note that images embedded in the buffer occupy 1 character slot, so <a class="el" href="classGtk_1_1TextIter.html#46acea844c69273d92c63d910eca21c9" title="Moves iter forward by one character offset.">forward_char()</a> may actually move onto an image instead of a character, if you have images in your buffer. If <em>iter</em> is the end iterator or one character before it, <em>iter</em> will now point at the end iterator, and <a class="el" href="classGtk_1_1TextIter.html#46acea844c69273d92c63d910eca21c9" title="Moves iter forward by one character offset.">forward_char()</a> returns <code>false</code> for convenience when writing loops. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="adbab55d587698d0f51776faa0cc2a43"></a><!-- doxytag: member="Gtk::TextIter::forward_chars" ref="adbab55d587698d0f51776faa0cc2a43" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_chars           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> characters if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
The return value indicates whether the new position of <em>iter</em> is different from its original position, and dereferenceable (the last iterator in the buffer is not dereferenceable). If <em>count</em> is 0, the function does nothing and returns <code>false</code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of characters to move, may be negative. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c43e1833c36390271f139096f2246684"></a><!-- doxytag: member="Gtk::TextIter::forward_cursor_position" ref="c43e1833c36390271f139096f2246684" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> forward by a single cursor position. 
<p>
Cursor positions are (unsurprisingly) positions where the cursor can appear. Perhaps surprisingly, there may not be a cursor position between all characters. The most common example for European languages would be a carriage return/newline sequence. For some Unicode characters, the equivalent of say the letter "a" with an accent mark will be represented as two characters, first the letter then a "combining mark" that causes the accent to be rendered; so the cursor can't go between those two characters. See also the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html#b0b3468a9efcaec7022885d46fd43d09">Pango::LogAttr</a> structure and pango_break() function. <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b20683d7513dfb331bb0a1aeffa63c5"></a><!-- doxytag: member="Gtk::TextIter::forward_cursor_positions" ref="8b20683d7513dfb331bb0a1aeffa63c5" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves up to <em>count</em> cursor positions. 
<p>
See <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1dd44d882c6ce3b85408712d3296c124"></a><!-- doxytag: member="Gtk::TextIter::forward_find_char" ref="1dd44d882c6ce3b85408712d3296c124" args="(const Predicate &amp;predicate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_find_char           </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3103d609ff2e2a08a2297141dff0fee4"></a><!-- doxytag: member="Gtk::TextIter::forward_find_char" ref="3103d609ff2e2a08a2297141dff0fee4" args="(const Predicate &amp;predicate, const TextIter &amp;limit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_find_char           </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ca8832f0168bbcf8651cff1eb632f13f"></a><!-- doxytag: member="Gtk::TextIter::forward_line" ref="ca8832f0168bbcf8651cff1eb632f13f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> to the start of the next line. 
<p>
If the iter is already on the last line of the buffer, moves the iter to the end of the current line. If after the operation, the iter is at the end of the buffer and not dereferencable, returns <code>false</code>. Otherwise, returns <code>true</code>. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> can be dereferenced. </dd></dl>

</div>
</div><p>
<a class="anchor" name="db054a9ee7862010ad5564571bda2552"></a><!-- doxytag: member="Gtk::TextIter::forward_lines" ref="db054a9ee7862010ad5564571bda2552" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_lines           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of lines to move forward. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dfa8920e9c706937136f4d2cdb75b83c"></a><!-- doxytag: member="Gtk::TextIter::forward_search" ref="dfa8920e9c706937136f4d2cdb75b83c" args="(const Glib::ustring &amp;str, TextSearchFlags flags, TextIter &amp;match_start, TextIter &amp;match_end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_search           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classGtk_1_1TextIter.html#e74bf1b660263296292752cb2795bea3" title="Searches forward for str.">forward_search()</a>, but searchs to the end. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags affecting how the search is done. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>Return location for start of match, or <code>0</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>Return location for end of match, or <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e74bf1b660263296292752cb2795bea3"></a><!-- doxytag: member="Gtk::TextIter::forward_search" ref="e74bf1b660263296292752cb2795bea3" args="(const Glib::ustring &amp;str, TextSearchFlags flags, TextIter &amp;match_start, TextIter &amp;match_end, const TextIter &amp;limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_search           </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#g45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches forward for <em>str</em>. 
<p>
Any match is returned by setting <em>match_start</em> to the first character of the match and <em>match_end</em> to the first character after the match. The search will not continue past <em>limit</em>. Note that a search is a linear or O(n) operation, so you may wish to use <em>limit</em> to avoid locking up your UI on large buffers.<p>
If the <a class="el" href="group__gtkmmEnums.html#gg45bb48ef86a7da2535de94066029bc290b28cb0bb916b26583fc45f408fe3862">Gtk::TEXT_SEARCH_VISIBLE_ONLY</a> flag is present, the match may have invisible text interspersed in <em>str</em>. i.e. <em>str</em> will be a possibly-noncontiguous subsequence of the matched range. similarly, if you specify <a class="el" href="group__gtkmmEnums.html#gg45bb48ef86a7da2535de94066029bc299e7c657edf1a930f28a43fb22314d063">Gtk::TEXT_SEARCH_TEXT_ONLY</a>, the match may have pixbufs or child widgets mixed inside the matched range. If these flags are not given, the match must be exact; the special 0xFFFC character in <em>str</em> will match embedded pixbufs or child widgets. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>A search string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags affecting how the search is done. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_start</em>&nbsp;</td><td>Return location for start of match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_end</em>&nbsp;</td><td>Return location for end of match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>Bound for the search. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a match was found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d1c3dc0fa3c7545e6a09aa082e4032e"></a><!-- doxytag: member="Gtk::TextIter::forward_sentence_end" ref="2d1c3dc0fa3c7545e6a09aa082e4032e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_sentence_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next sentence end. 
<p>
(If <em>iter</em> is at the end of a sentence, moves to the next end of sentence.) Sentence boundaries are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> text boundary algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6aef31e21147f939af5f34ef930f16bf"></a><!-- doxytag: member="Gtk::TextIter::forward_sentence_ends" ref="6aef31e21147f939af5f34ef930f16bf" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_sentence_ends           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextIter.html#2d1c3dc0fa3c7545e6a09aa082e4032e" title="Moves forward to the next sentence end.">forward_sentence_end()</a> <em>count</em> times (or until <a class="el" href="classGtk_1_1TextIter.html#2d1c3dc0fa3c7545e6a09aa082e4032e" title="Moves forward to the next sentence end.">forward_sentence_end()</a> returns <code>false</code>). 
<p>
If <em>count</em> is negative, moves backward instead of forward. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of sentences to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="70abfc30933f0e8dec3f014128443dc4"></a><!-- doxytag: member="Gtk::TextIter::forward_to_end" ref="70abfc30933f0e8dec3f014128443dc4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::forward_to_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> forward to the "end iterator," which points one past the last valid character in the buffer. 
<p>
<a class="el" href="classGtk_1_1TextIter.html#63cd8afd6fb53bdedef424b42bbc66b7" title="returns 0.">get_char()</a> called on the end iterator returns 0, which is convenient for writing loops. 
</div>
</div><p>
<a class="anchor" name="31f8195cab1810e35b88122d2ebd7b90"></a><!-- doxytag: member="Gtk::TextIter::forward_to_line_end" ref="31f8195cab1810e35b88122d2ebd7b90" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_to_line_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character. 
<p>
If the iterator is already at the paragraph delimiter characters, moves to the paragraph delimiter characters for the next line. If <em>iter</em> is on the last line in the buffer, which does not end in paragraph delimiters, moves to the end iterator (end of the last line), and returns <code>false</code>. <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new location is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="89b4fc66df6e0b9b8046c2f70b261629"></a><!-- doxytag: member="Gtk::TextIter::forward_to_tag_toggle" ref="89b4fc66df6e0b9b8046c2f70b261629" args="(const Glib::RefPtr&lt; TextTag &gt; &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_to_tag_toggle           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>0</code>. 
<p>
If no matching tag toggles are found, Return value: whether we found a tag toggle after <em>iter</em> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether we found a tag toggle after <em>iter</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="647f1e0b30b3ad9470d67f8d42108d6a"></a><!-- doxytag: member="Gtk::TextIter::forward_visible_cursor_position" ref="647f1e0b30b3ad9470d67f8d42108d6a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> forward to the next visible cursor position. 
<p>
See <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a> for details. <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new position is dereferenceable</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000228">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="770ab9cd1f2dd86d586567cb19f8d9a4"></a><!-- doxytag: member="Gtk::TextIter::forward_visible_cursor_positions" ref="770ab9cd1f2dd86d586567cb19f8d9a4" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_cursor_positions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves up to <em>count</em> visible cursor positions. 
<p>
See <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of positions to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if we moved and the new position is dereferenceable</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000230">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="55a295c7dead80d24470f33a67a6dd74"></a><!-- doxytag: member="Gtk::TextIter::forward_visible_line" ref="55a295c7dead80d24470f33a67a6dd74" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_line           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>count</em> visible lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). 
<p>
The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of lines to move forward. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> moved and is dereferenceable</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p8s.html#_newin2p8s000042">Since gtkmm 2.8:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="506be5cb9d7dd29522b71cddd520bda3"></a><!-- doxytag: member="Gtk::TextIter::forward_visible_line" ref="506be5cb9d7dd29522b71cddd520bda3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> to the start of the next visible line. 
<p>
Returns <code>true</code> if there was a next line to move to, and <code>false</code> if <em>iter</em> was simply moved to the end of the buffer and is now not dereferenceable, or if <em>iter</em> was already at the end of the buffer. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> can be dereferenced</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p8s.html#_newin2p8s000040">Since gtkmm 2.8:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="c79bd3e6c8cd7ccdc45b8ed8064986e8"></a><!-- doxytag: member="Gtk::TextIter::forward_visible_word_end" ref="c79bd3e6c8cd7ccdc45b8ed8064986e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_word_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next visible word end. 
<p>
(If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> word break algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000224">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="d9a7521c3392d07d24790702433cd1ff"></a><!-- doxytag: member="Gtk::TextIter::forward_visible_word_ends" ref="d9a7521c3392d07d24790702433cd1ff" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_word_ends           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextIter.html#c79bd3e6c8cd7ccdc45b8ed8064986e8" title="Moves forward to the next visible word end.">forward_visible_word_end()</a> up to <em>count</em> times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator</dd></dl>
<dl compact><dt><b><a class="el" href="newin2p4s.html#_newin2p4s000226">Since gtkmm 2.4:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="05bba655ab512cf1569590d9206d797b"></a><!-- doxytag: member="Gtk::TextIter::forward_word_end" ref="05bba655ab512cf1569590d9206d797b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_word_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves forward to the next word end. 
<p>
(If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> word break algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a7d74cb53546701ec0b42266ac40e2a1"></a><!-- doxytag: member="Gtk::TextIter::forward_word_ends" ref="a7d74cb53546701ec0b42266ac40e2a1" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_word_ends           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classGtk_1_1TextIter.html#05bba655ab512cf1569590d9206d797b" title="Moves forward to the next word end.">forward_word_end()</a> up to <em>count</em> times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of times to move. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b83601605d0226595e4f36477bc666ce"></a><!-- doxytag: member="Gtk::TextIter::get_attributes" ref="b83601605d0226595e4f36477bc666ce" args="(TextAttributes &amp;values) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::get_attributes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextAttributes.html">TextAttributes</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>values</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f2244ebff821e640cd163779711d96a8"></a><!-- doxytag: member="Gtk::TextIter::get_buffer" ref="f2244ebff821e640cd163779711d96a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a>&gt; Gtk::TextIter::get_buffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: the buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66ae8164fd98bc8552956138800fb547"></a><!-- doxytag: member="Gtk::TextIter::get_bytes_in_line" ref="66ae8164fd98bc8552956138800fb547" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_bytes_in_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: number of bytes in the line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes in the line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="63cd8afd6fb53bdedef424b42bbc66b7"></a><!-- doxytag: member="Gtk::TextIter::get_char" ref="63cd8afd6fb53bdedef424b42bbc66b7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gunichar Gtk::TextIter::get_char           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns 0. 
<p>
Return value: a Unicode character, or 0 if <em>iter</em> is not dereferenceable <dl class="return" compact><dt><b>Returns:</b></dt><dd>A Unicode character, or 0 if <em>iter</em> is not dereferenceable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fecdd3d4363598c3cc5058965d0dac2b"></a><!-- doxytag: member="Gtk::TextIter::get_chars_in_line" ref="fecdd3d4363598c3cc5058965d0dac2b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_chars_in_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: number of characters in the line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters in the line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="682ce9b6067548ab103cd3f64867b986"></a><!-- doxytag: member="Gtk::TextIter::get_child_anchor" ref="682ce9b6067548ab103cd3f64867b986" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a>&gt; Gtk::TextIter::get_child_anchor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the location at <em>iter</em> contains a child anchor, the anchor is returned (with no new reference count added). 
<p>
Otherwise, <code>0</code> is returned. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The anchor at <em>iter</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8ee402bb518aeed4aeef15f29710cb4"></a><!-- doxytag: member="Gtk::TextIter::get_child_anchor" ref="b8ee402bb518aeed4aeef15f29710cb4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a>&gt; Gtk::TextIter::get_child_anchor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the location at <em>iter</em> contains a child anchor, the anchor is returned (with no new reference count added). 
<p>
Otherwise, <code>0</code> is returned. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The anchor at <em>iter</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f47c3ce2b5a03bae097c878c07b5daec"></a><!-- doxytag: member="Gtk::TextIter::get_language" ref="f47c3ce2b5a03bae097c878c07b5daec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/classPango_1_1Language.html">Pango::Language</a> Gtk::TextIter::get_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A convenience wrapper around <a class="el" href="classGtk_1_1TextIter.html#b83601605d0226595e4f36477bc666ce">get_attributes()</a>, which returns the language in effect at <em>iter</em>. 
<p>
If no tags affecting language apply to <em>iter</em>, the return value is identical to that of gtk_get_default_language(). <dl class="return" compact><dt><b>Returns:</b></dt><dd>Language in effect at <em>iter</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e51ca638396eb61fd1997b6c1538f0c7"></a><!-- doxytag: member="Gtk::TextIter::get_line" ref="e51ca638396eb61fd1997b6c1538f0c7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: a line number. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A line number. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a0c83b81f49e182c60e7f7c40fad8f8"></a><!-- doxytag: member="Gtk::TextIter::get_line_index" ref="4a0c83b81f49e182c60e7f7c40fad8f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_line_index           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: distance from start of line, in bytes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Distance from start of line, in bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="93ea3d3cfcc39f69555545b4bdd38530"></a><!-- doxytag: member="Gtk::TextIter::get_line_offset" ref="93ea3d3cfcc39f69555545b4bdd38530" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_line_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: offset from start of line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Offset from start of line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="816e1c24bb5462aec8d4d540044a6239"></a><!-- doxytag: member="Gtk::TextIter::get_marks" ref="816e1c24bb5462aec8d4d540044a6239" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt;Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextMark.html">TextMark</a>&gt;&gt; Gtk::TextIter::get_marks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: list of <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>List of <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a6dc67578010ba3d16375d3fd3810ee0"></a><!-- doxytag: member="Gtk::TextIter::get_marks" ref="a6dc67578010ba3d16375d3fd3810ee0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextMark.html">TextMark</a>&gt;&gt; Gtk::TextIter::get_marks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: list of <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>List of <a class="el" href="classGtk_1_1TextMark.html" title="Typedefed as Gtk::TextBuffer::Mark.">Gtk::TextMark</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="23db9e028b016cda6fd3af40fb3ef1af"></a><!-- doxytag: member="Gtk::TextIter::get_offset" ref="23db9e028b016cda6fd3af40fb3ef1af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: a character offset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A character offset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4813d198441c620d2afbec63be45ccc"></a><!-- doxytag: member="Gtk::TextIter::get_pixbuf" ref="c4813d198441c620d2afbec63be45ccc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a>&gt; Gtk::TextIter::get_pixbuf           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the element at <em>iter</em> is a pixbuf, the pixbuf is returned (with no new reference count added). 
<p>
Otherwise, <code>0</code> is returned. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The pixbuf at <em>iter</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cbf2a271e33232170e1c41ccb1aa12e1"></a><!-- doxytag: member="Gtk::TextIter::get_slice" ref="cbf2a271e33232170e1c41ccb1aa12e1" args="(const TextIter &amp;end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_slice           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: slice of text from the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Iterator at end of a range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Slice of text from the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="749b813bb4c369bff9e04e6f79d487aa"></a><!-- doxytag: member="Gtk::TextIter::get_tags" ref="749b813bb4c369bff9e04e6f79d487aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt;Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt; Gtk::TextIter::get_tags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of tags that apply to <em>iter</em>, in ascending order of priority (highest-priority tags are last). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>List of <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e7bb7f1d6de6949cb995d316307ec0bb"></a><!-- doxytag: member="Gtk::TextIter::get_tags" ref="e7bb7f1d6de6949cb995d316307ec0bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt; Gtk::TextIter::get_tags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of tags that apply to <em>iter</em>, in ascending order of priority (highest-priority tags are last). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>List of <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="68fceee86d4913529a918872438cff8a"></a><!-- doxytag: member="Gtk::TextIter::get_text" ref="68fceee86d4913529a918872438cff8a" args="(const TextIter &amp;end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: array of characters from the buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Iterator at end of a range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Array of characters from the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eca8604e9583471ca6b76ab14bb1030a"></a><!-- doxytag: member="Gtk::TextIter::get_toggled_tags" ref="eca8604e9583471ca6b76ab14bb1030a" args="(bool toggled_on=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt;Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt; Gtk::TextIter::get_toggled_tags           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toggled_on</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: tags toggled at this point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toggled_on</em>&nbsp;</td><td><code>true</code> to get toggled-on tags. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Tags toggled at this point. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f320581d5694946f227130116909c27f"></a><!-- doxytag: member="Gtk::TextIter::get_toggled_tags" ref="f320581d5694946f227130116909c27f" args="(bool toggled_on=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt;Glib::RefPtr&lt;<a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&gt; Gtk::TextIter::get_toggled_tags           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toggled_on</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: tags toggled at this point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toggled_on</em>&nbsp;</td><td><code>true</code> to get toggled-on tags. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Tags toggled at this point. </dd></dl>

</div>
</div><p>
<a class="anchor" name="726f03533f659eba9d58cdcb7e3752ae"></a><!-- doxytag: member="Gtk::TextIter::get_visible_line_index" ref="726f03533f659eba9d58cdcb7e3752ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_visible_line_index           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: byte index of <em>iter</em> with respect to the start of the line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Byte index of <em>iter</em> with respect to the start of the line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff8216613df48ec3ec109ef60e7dbdb2"></a><!-- doxytag: member="Gtk::TextIter::get_visible_line_offset" ref="ff8216613df48ec3ec109ef60e7dbdb2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_visible_line_offset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: offset in visible characters from the start of the line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Offset in visible characters from the start of the line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0972fc9b1892e9199c60779634c5bde5"></a><!-- doxytag: member="Gtk::TextIter::get_visible_slice" ref="0972fc9b1892e9199c60779634c5bde5" args="(const TextIter &amp;end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_visible_slice           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classGtk_1_1TextIter.html#cbf2a271e33232170e1c41ccb1aa12e1" title="Return value: slice of text from the buffer.">get_slice()</a>, but invisible text is not included. 
<p>
<a class="el" href="classGtk_1_1Invisible.html" title="This widget is used internally in GTK+, and is probably not useful for application...">Invisible</a> text is usually invisible because a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a> with the "invisible" attribute turned on has been applied to it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Iterator at end of range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Slice of text from the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="15ec6157320b54c7b16952e2005e106b"></a><!-- doxytag: member="Gtk::TextIter::get_visible_text" ref="15ec6157320b54c7b16952e2005e106b" args="(const TextIter &amp;end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_visible_text           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classGtk_1_1TextIter.html#68fceee86d4913529a918872438cff8a" title="Return value: array of characters from the buffer.">get_text()</a>, but invisible text is not included. 
<p>
<a class="el" href="classGtk_1_1Invisible.html" title="This widget is used internally in GTK+, and is probably not useful for application...">Invisible</a> text is usually invisible because a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a> with the "invisible" attribute turned on has been applied to it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Iterator at end of range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>String containing visible text in the range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="050314ca046487d60c14a13085d0b0a3"></a><!-- doxytag: member="Gtk::TextIter::gobj" ref="050314ca046487d60c14a13085d0b0a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GtkTextIter* Gtk::TextIter::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C instance. 
<p>

</div>
</div><p>
<a class="anchor" name="c5fe90901048c857a70fdcf6bfc83e5d"></a><!-- doxytag: member="Gtk::TextIter::gobj" ref="c5fe90901048c857a70fdcf6bfc83e5d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GtkTextIter* Gtk::TextIter::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C instance. 
<p>

</div>
</div><p>
<a class="anchor" name="b6bc228450c06a466e28717da8e8d1b5"></a><!-- doxytag: member="Gtk::TextIter::has_tag" ref="b6bc228450c06a466e28717da8e8d1b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::has_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3f3c8fbd79f6f8bd50e3831ee4661a96"></a><!-- doxytag: member="Gtk::TextIter::has_tag" ref="3f3c8fbd79f6f8bd50e3831ee4661a96" args="(const Glib::RefPtr&lt; const TextTag &gt; &amp;tag) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::has_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> is tagged with <em>tag</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> is tagged with <em>tag</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b537dff76037393f0abec24859561f3c"></a><!-- doxytag: member="Gtk::TextIter::in_range" ref="b537dff76037393f0abec24859561f3c" args="(const TextIter &amp;start, const TextIter &amp;end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::in_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether <em>iter</em> falls in the range [ <em>start</em>, <em>end</em>). 
<p>
<em>start</em> and <em>end</em> must be in ascending order. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start of range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> is in the range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29ff52b7b859a529ce8036615a7ea11b"></a><!-- doxytag: member="Gtk::TextIter::inside_sentence" ref="29ff52b7b859a529ce8036615a7ea11b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::inside_sentence           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether <em>iter</em> is inside a sentence (as opposed to in between two sentences, e.g. after a period and before the first letter of the next sentence). 
<p>
Sentence boundaries are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> text boundary algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> is inside a sentence. </dd></dl>

</div>
</div><p>
<a class="anchor" name="63e3578d35cf55bf9ca33bfcac6cf716"></a><!-- doxytag: member="Gtk::TextIter::inside_word" ref="63e3578d35cf55bf9ca33bfcac6cf716" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::inside_word           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether <em>iter</em> is inside a natural-language word (as opposed to say inside some whitespace). 
<p>
Word breaks are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> word break algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> is inside a word. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f1cce58629dbc6058576dff992cded0"></a><!-- doxytag: member="Gtk::TextIter::is_cursor_position" ref="6f1cce58629dbc6058576dff992cded0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::is_cursor_position           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See <a class="el" href="classGtk_1_1TextIter.html#c43e1833c36390271f139096f2246684" title="Moves iter forward by a single cursor position.">forward_cursor_position()</a> or <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html#b0b3468a9efcaec7022885d46fd43d09">Pango::LogAttr</a> or pango_break() for details on what a cursor position is. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the cursor can be placed at <em>iter</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="87078ad316a037bdd04a40d85145be3e"></a><!-- doxytag: member="Gtk::TextIter::is_end" ref="87078ad316a037bdd04a40d85145be3e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::is_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> is the end iterator. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> is the end iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="218044fcce516c2982b2e54225619b93"></a><!-- doxytag: member="Gtk::TextIter::is_start" ref="218044fcce516c2982b2e54225619b93" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::is_start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> is the first in the buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> is the first in the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d5012897961552a524589378af6c17f"></a><!-- doxytag: member="Gtk::TextIter::operator bool" ref="6d5012897961552a524589378af6c17f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextIter::operator bool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for !is_end(). 
<p>

</div>
</div><p>
<a class="anchor" name="25bc72debbe24fa32719261d591949e7"></a><!-- doxytag: member="Gtk::TextIter::operator*" ref="25bc72debbe24fa32719261d591949e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html#e1f6efe5a5875e7198e3de43c64e2db0">value_type</a> Gtk::TextIter::operator*           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="classGtk_1_1TextIter.html#63cd8afd6fb53bdedef424b42bbc66b7" title="returns 0.">get_char()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="e27c3a2f0663071f9319fe140f047b72"></a><!-- doxytag: member="Gtk::TextIter::operator++" ref="e27c3a2f0663071f9319fe140f047b72" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> Gtk::TextIter::operator++           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="11ef1de054169a9ca48cca88d03ad04e"></a><!-- doxytag: member="Gtk::TextIter::operator++" ref="11ef1de054169a9ca48cca88d03ad04e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; Gtk::TextIter::operator++           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="classGtk_1_1TextIter.html#46acea844c69273d92c63d910eca21c9" title="Moves iter forward by one character offset.">forward_char()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="e9050a524dda968db856b3e791fc833d"></a><!-- doxytag: member="Gtk::TextIter::operator&#45;&#45;" ref="e9050a524dda968db856b3e791fc833d" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> Gtk::TextIter::operator--           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d1fea62e0f049dac87497aadc4e32ac2"></a><!-- doxytag: member="Gtk::TextIter::operator&#45;&#45;" ref="d1fea62e0f049dac87497aadc4e32ac2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp; Gtk::TextIter::operator--           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="classGtk_1_1TextIter.html#eff64dab2ff97e06452f4ca7c030b758" title="Moves backward by one character offset.">backward_char()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="4d3c25edf1efe92f5313ac740781238b"></a><!-- doxytag: member="Gtk::TextIter::order" ref="4d3c25edf1efe92f5313ac740781238b" args="(TextIter &amp;second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::order           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>second</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the value of <em>first</em> and <em>second</em> if <em>second</em> comes before <em>first</em> in the buffer. 
<p>
That is, ensures that <em>first</em> and <em>second</em> are in sequence. Most text buffer functions that take a range call this automatically on your behalf, so there's no real reason to call it yourself in those cases. There are some exceptions, such as <a class="el" href="classGtk_1_1TextIter.html#b537dff76037393f0abec24859561f3c" title="Checks whether iter falls in the range [ start, end).">in_range()</a>, that expect a pre-sorted range. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>Another <a class="el" href="classGtk_1_1TextIter.html" title="Typefed as Gtk::TextBuffer::iterator.">Gtk::TextIter</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bfba7a50f3ec781d151cc5643e1b4083"></a><!-- doxytag: member="Gtk::TextIter::set_line" ref="bfba7a50f3ec781d151cc5643e1b4083" args="(int line_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_line           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves iterator <em>iter</em> to the start of the line <em>line_number</em>. 
<p>
If <em>line_number</em> is negative or larger than the number of lines in the buffer, moves <em>iter</em> to the start of the last line in the buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_number</em>&nbsp;</td><td>Line number (counted from 0). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f63b8c2520413efdde54dd8ad5670579"></a><!-- doxytag: member="Gtk::TextIter::set_line_index" ref="f63b8c2520413efdde54dd8ad5670579" args="(int byte_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_line_index           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byte_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classGtk_1_1TextIter.html#62c90b4327191537170c796a23d06b25" title="Moves iter within a line, to a new character (not byte) offset.">set_line_offset()</a>, but works with a <em>byte</em> index. 
<p>
The given byte index must be at the start of a character, it can't be in the middle of a UTF-8 encoded character. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>byte_on_line</em>&nbsp;</td><td>A byte index relative to the start of <em>iter's</em> current line. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="62c90b4327191537170c796a23d06b25"></a><!-- doxytag: member="Gtk::TextIter::set_line_offset" ref="62c90b4327191537170c796a23d06b25" args="(int char_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_line_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves <em>iter</em> within a line, to a new <em>character</em> (not byte) offset. 
<p>
The given character offset must be less than or equal to the number of characters in the line; if equal, <em>iter</em> moves to the start of the next line. See <a class="el" href="classGtk_1_1TextIter.html#f63b8c2520413efdde54dd8ad5670579" title="Same as set_line_offset(), but works with a byte index.">set_line_index()</a> if you have a byte index rather than a character offset. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_on_line</em>&nbsp;</td><td>A character offset relative to the start of <em>iter's</em> current line. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="00ce173ce4d3622cc36e48d5bff2374f"></a><!-- doxytag: member="Gtk::TextIter::set_offset" ref="00ce173ce4d3622cc36e48d5bff2374f" args="(int char_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets <em>iter</em> to point to <em>char_offset</em>. 
<p>
<em>char_offset</em> counts from the start of the entire text buffer, starting with 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_offset</em>&nbsp;</td><td>A character number. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40b3039e099a9c3d752b8a3809d1ae4d"></a><!-- doxytag: member="Gtk::TextIter::set_visible_line_index" ref="40b3039e099a9c3d752b8a3809d1ae4d" args="(int byte_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_visible_line_index           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byte_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classGtk_1_1TextIter.html#f63b8c2520413efdde54dd8ad5670579" title="Same as set_line_offset(), but works with a byte index.">set_line_index()</a>, but the index is in visible bytes, i.e. text with a tag making it invisible is not counted in the index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>byte_on_line</em>&nbsp;</td><td>A byte index. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ccd69e5353e073ce841ff0e02ac6a7e"></a><!-- doxytag: member="Gtk::TextIter::set_visible_line_offset" ref="7ccd69e5353e073ce841ff0e02ac6a7e" args="(int char_on_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_visible_line_offset           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>char_on_line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="classGtk_1_1TextIter.html#62c90b4327191537170c796a23d06b25" title="Moves iter within a line, to a new character (not byte) offset.">set_line_offset()</a>, but the offset is in visible characters, i.e. text with a tag making it invisible is not counted in the offset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>char_on_line</em>&nbsp;</td><td>A character offset. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3af99cb623ef41f2c1ec23e87a27b31a"></a><!-- doxytag: member="Gtk::TextIter::starts_line" ref="3af99cb623ef41f2c1ec23e87a27b31a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::starts_line           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value: whether <em>iter</em> begins a line. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>iter</em> begins a line. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e3ea3c5bcb8aa11ecaeea2be490323b"></a><!-- doxytag: member="Gtk::TextIter::starts_sentence" ref="5e3ea3c5bcb8aa11ecaeea2be490323b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::starts_sentence           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether <em>iter</em> begins a sentence. 
<p>
Sentence boundaries are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> text boundary algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> is at the start of a sentence. </dd></dl>

</div>
</div><p>
<a class="anchor" name="727ff792013d3b9d1b2c28ed4b2af514"></a><!-- doxytag: member="Gtk::TextIter::starts_word" ref="727ff792013d3b9d1b2c28ed4b2af514" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::starts_word           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether <em>iter</em> begins a natural-language word. 
<p>
Word breaks are determined by <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm_doxygen_tags:../../../../pangomm-1.4/docs/reference/html/" href="../../../../pangomm-1.4/docs/reference/html/namespacePango.html">Pango</a> word break algorithms). <dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if <em>iter</em> is at the start of a word. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e9932c4003339e1f294ebd33dec309ed"></a><!-- doxytag: member="Gtk::TextIter::toggles_tag" ref="e9932c4003339e1f294ebd33dec309ed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::toggles_tag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1b8a333956be379051b987521f383c1b"></a><!-- doxytag: member="Gtk::TextIter::toggles_tag" ref="1b8a333956be379051b987521f383c1b" args="(const Glib::RefPtr&lt; const TextTag &gt; &amp;tag) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::toggles_tag           </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt;const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is equivalent to (<a class="el" href="classGtk_1_1TextIter.html#fa90f81adb24aa2a32696aad22f78c46" title="Return value: whether iter is the start of a range tagged with tag.">begins_tag()</a> || <a class="el" href="classGtk_1_1TextIter.html#69904722c3b9e761eae2aba31d5a88d5" title="Return value: whether iter is the end of a range tagged with tag.">ends_tag()</a>), i.e. it tells you whether a range with <em>tag</em> applied to it begins <em>or</em> ends at <em>iter</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag.">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether <em>tag</em> is toggled on or off at <em>iter</em>. </dd></dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="0e373b53b974fbab36b1d45ebd206c76"></a><!-- doxytag: member="Gtk::TextIter::operator!=" ref="0e373b53b974fbab36b1d45ebd206c76" args="(const TextIter &amp;lhs, const TextIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left-hand side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right-hand side </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div><p>
<a class="anchor" name="1cdd13320f231bd906520131cdc138d2"></a><!-- doxytag: member="Gtk::TextIter::operator&lt;" ref="1cdd13320f231bd906520131cdc138d2" args="(const TextIter &amp;lhs, const TextIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left-hand side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right-hand side </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div><p>
<a class="anchor" name="76f0b1315ba7b06bbdfbdd2e029bda73"></a><!-- doxytag: member="Gtk::TextIter::operator&lt;=" ref="76f0b1315ba7b06bbdfbdd2e029bda73" args="(const TextIter &amp;lhs, const TextIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left-hand side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right-hand side </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div><p>
<a class="anchor" name="8703a159b88dc5e8dd8d4ea361667281"></a><!-- doxytag: member="Gtk::TextIter::operator==" ref="8703a159b88dc5e8dd8d4ea361667281" args="(const TextIter &amp;lhs, const TextIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left-hand side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right-hand side </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div><p>
<a class="anchor" name="d50c7c8990fac0c51ac460034ff5f3c4"></a><!-- doxytag: member="Gtk::TextIter::operator&gt;" ref="d50c7c8990fac0c51ac460034ff5f3c4" args="(const TextIter &amp;lhs, const TextIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left-hand side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right-hand side </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div><p>
<a class="anchor" name="387ff6ec0c707b3a30ea7398cdc601d2"></a><!-- doxytag: member="Gtk::TextIter::operator&gt;=" ref="387ff6ec0c707b3a30ea7398cdc601d2" args="(const TextIter &amp;lhs, const TextIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left-hand side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right-hand side </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d77ba6925f3144ad49e36412791b7aa"></a><!-- doxytag: member="Gtk::TextIter::wrap" ref="5d77ba6925f3144ad49e36412791b7aa" args="(const GtkTextIter *object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a>&amp; wrap           </td>
          <td>(</td>
          <td class="paramtype">const GtkTextIter *&nbsp;</td>
          <td class="paramname"> <em>object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The C instance </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5497a6a3458131b32c6aaa0fcab3f511"></a><!-- doxytag: member="Gtk::TextIter::wrap" ref="5497a6a3458131b32c6aaa0fcab3f511" args="(GtkTextIter *object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a>&amp; wrap           </td>
          <td>(</td>
          <td class="paramtype">GtkTextIter *&nbsp;</td>
          <td class="paramname"> <em>object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The C instance </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="533d80230ee6366bc575bed7369f4afb"></a><!-- doxytag: member="Gtk::TextIter::gobject_" ref="533d80230ee6366bc575bed7369f4afb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GtkTextIter <a class="el" href="classGtk_1_1TextIter.html#533d80230ee6366bc575bed7369f4afb">Gtk::TextIter::gobject_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="textiter_8h.html">textiter.h</a></ul>
</div>
</div>
<!-- end main content -->

<hr><address><small>
Generated for gtkmm 2.4 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.8 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
