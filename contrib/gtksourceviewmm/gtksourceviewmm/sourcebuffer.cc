// Generated by gtkmmproc -- DO NOT MODIFY!


#include <gtksourceviewmm/sourcebuffer.h>
#include <gtksourceviewmm/private/sourcebuffer_p.h>

/* sourcebuffer.hg
 * 
 * Copyright (C) 2004-2005 Jae Jang
 * Copyright (C) 2005-2006 Rob Page
 * Copyright (C)2006 Dodji Seketeli
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
#include <gtksourceviewmm/sourcebuffer.h>
#include <gtksourceview/gtksourcebuffer.h>

namespace gtksourceview
{

SourceBuffer::SourceBuffer (const Glib::RefPtr<SourceLanguage> &language) :
    // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Gtk::TextBuffer(Glib::ConstructParams(sourcebuffer_class_.init()))
{
    if (language)
    {
        gtk_source_buffer_set_language (GTK_SOURCE_BUFFER (gobject_),
                                        language->gobj ()) ;
    }
    else
    {
        gtk_source_buffer_set_language (GTK_SOURCE_BUFFER (gobject_),
                                        NULL) ;
    }
}

bool SourceBuffer::backward_iter_to_source_mark(Gtk::TextIter& iter)
{
    return gtk_source_buffer_backward_iter_to_source_mark(gobj(), iter.gobj(), NULL);
}

bool SourceBuffer::forward_iter_to_source_mark(Gtk::TextIter& iter)
{
    return gtk_source_buffer_forward_iter_to_source_mark(gobj(), iter.gobj(), NULL);
}

Glib::SListHandle<Glib::RefPtr<SourceMark> > SourceBuffer::get_source_marks_at_line(int line) const
{
    return Glib::SListHandle<Glib::RefPtr<SourceMark> >(gtk_source_buffer_get_source_marks_at_line(const_cast<GtkSourceBuffer*>(gobj()), line, NULL), Glib::OWNERSHIP_SHALLOW);
}

Glib::SListHandle<Glib::RefPtr<SourceMark> > SourceBuffer::get_source_marks_at_iter(Gtk::TextIter& iter) const
{
    return Glib::SListHandle<Glib::RefPtr<SourceMark> >(gtk_source_buffer_get_source_marks_at_iter(const_cast<GtkSourceBuffer*>(gobj()), iter.gobj(), NULL), Glib::OWNERSHIP_SHALLOW);
}

}//end namespace gtksourceview


namespace
{


static void SourceBuffer_signal_highlight_updated_callback(GtkSourceBuffer* self, GtkTextIter* p0,GtkTextIter* p1,void* data)
{
  using namespace gtksourceview;
  typedef sigc::slot< void,Gtk::TextIter&,Gtk::TextIter& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0)
, Glib::wrap(p1)
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo SourceBuffer_signal_highlight_updated_info =
{
  "highlight-updated",
  (GCallback) &SourceBuffer_signal_highlight_updated_callback,
  (GCallback) &SourceBuffer_signal_highlight_updated_callback
};


static void SourceBuffer_signal_source_mark_updated_callback(GtkSourceBuffer* self, GtkSourceMark* p0,void* data)
{
  using namespace gtksourceview;
  typedef sigc::slot< void,const Glib::RefPtr<SourceMark>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo SourceBuffer_signal_source_mark_updated_info =
{
  "source-mark-updated",
  (GCallback) &SourceBuffer_signal_source_mark_updated_callback,
  (GCallback) &SourceBuffer_signal_source_mark_updated_callback
};


} // anonymous namespace


namespace Glib
{

Glib::RefPtr<gtksourceview::SourceBuffer> wrap(GtkSourceBuffer* object, bool take_copy)
{
  return Glib::RefPtr<gtksourceview::SourceBuffer>( dynamic_cast<gtksourceview::SourceBuffer*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace gtksourceview
{


/* The *_Class implementation: */

const Glib::Class& SourceBuffer_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &SourceBuffer_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_source_buffer_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}

void SourceBuffer_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED

#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
}

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED

#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED


Glib::ObjectBase* SourceBuffer_Class::wrap_new(GObject* object)
{
  return new SourceBuffer((GtkSourceBuffer*)object);
}


/* The implementation: */

GtkSourceBuffer* SourceBuffer::gobj_copy()
{
  reference();
  return gobj();
}

SourceBuffer::SourceBuffer(const Glib::ConstructParams& construct_params)
:
  Gtk::TextBuffer(construct_params)
{

}

SourceBuffer::SourceBuffer(GtkSourceBuffer* castitem)
:
  Gtk::TextBuffer((GtkTextBuffer*)(castitem))
{}

SourceBuffer::~SourceBuffer()
{}


SourceBuffer::CppClassType SourceBuffer::sourcebuffer_class_; // initialize static member

GType SourceBuffer::get_type()
{
  return sourcebuffer_class_.init().get_type();
}

GType SourceBuffer::get_base_type()
{
  return gtk_source_buffer_get_type();
}


SourceBuffer::SourceBuffer()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Gtk::TextBuffer(Glib::ConstructParams(sourcebuffer_class_.init()))
{
  

}

SourceBuffer::SourceBuffer(const Glib::RefPtr<Gtk::TextTagTable>& tagtable)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Gtk::TextBuffer(Glib::ConstructParams(sourcebuffer_class_.init(), "tagtable", Glib::unwrap(tagtable), static_cast<char*>(0)))
{
  

}

Glib::RefPtr<SourceBuffer> SourceBuffer::create(const Glib::RefPtr<Gtk::TextTagTable>& tagtable)
{
  return Glib::RefPtr<SourceBuffer>( new SourceBuffer(tagtable) );
}
Glib::RefPtr<SourceBuffer> SourceBuffer::create(const Glib::RefPtr<SourceLanguage>& language)
{
  return Glib::RefPtr<SourceBuffer>( new SourceBuffer(language) );
}
bool SourceBuffer::get_highlight_matching_brackets() const
{
  return gtk_source_buffer_get_highlight_matching_brackets(const_cast<GtkSourceBuffer*>(gobj()));
}

void SourceBuffer::set_highlight_matching_brackets(bool highlight)
{
gtk_source_buffer_set_highlight_matching_brackets(gobj(), static_cast<int>(highlight)); 
}

bool SourceBuffer::get_highlight_syntax() const
{
  return gtk_source_buffer_get_highlight_syntax(const_cast<GtkSourceBuffer*>(gobj()));
}

void SourceBuffer::set_highlight_syntax(bool highlight)
{
gtk_source_buffer_set_highlight_syntax(gobj(), static_cast<int>(highlight)); 
}

int SourceBuffer::get_max_undo_levels() const
{
  return gtk_source_buffer_get_max_undo_levels(const_cast<GtkSourceBuffer*>(gobj()));
}

void SourceBuffer::set_max_undo_levels(int max_undo_levels)
{
gtk_source_buffer_set_max_undo_levels(gobj(), max_undo_levels); 
}

Glib::RefPtr<SourceLanguage> SourceBuffer::get_language()
{

  Glib::RefPtr<SourceLanguage> retvalue = Glib::wrap(gtk_source_buffer_get_language(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const SourceLanguage> SourceBuffer::get_language() const
{
  return const_cast<SourceBuffer*>(this)->get_language();
}

void SourceBuffer::set_language(const Glib::RefPtr<SourceLanguage>& language)
{
gtk_source_buffer_set_language(gobj(), Glib::unwrap(language)); 
}

bool SourceBuffer::can_undo() const
{
  return gtk_source_buffer_can_undo(const_cast<GtkSourceBuffer*>(gobj()));
}

bool SourceBuffer::can_redo() const
{
  return gtk_source_buffer_can_redo(const_cast<GtkSourceBuffer*>(gobj()));
}

void SourceBuffer::undo()
{
gtk_source_buffer_undo(gobj()); 
}

void SourceBuffer::redo()
{
gtk_source_buffer_redo(gobj()); 
}

void SourceBuffer::begin_not_undoable_action()
{
gtk_source_buffer_begin_not_undoable_action(gobj()); 
}

void SourceBuffer::end_not_undoable_action()
{
gtk_source_buffer_end_not_undoable_action(gobj()); 
}

bool SourceBuffer::backward_iter_to_source_mark(Gtk::TextIter& iter, const Glib::ustring& category)
{
  return gtk_source_buffer_backward_iter_to_source_mark(gobj(), iter.gobj(), category.c_str());
}

bool SourceBuffer::forward_iter_to_source_mark(Gtk::TextIter& iter, const Glib::ustring& category)
{
  return gtk_source_buffer_forward_iter_to_source_mark(gobj(), iter.gobj(), category.c_str());
}

void SourceBuffer::ensure_highlight(const Gtk::TextIter& start, const Gtk::TextIter& end)
{
gtk_source_buffer_ensure_highlight(gobj(), start.gobj(), end.gobj()); 
}

void SourceBuffer::set_style_scheme(const Glib::RefPtr<SourceStyleScheme>& scheme)
{
gtk_source_buffer_set_style_scheme(gobj(), Glib::unwrap(scheme)); 
}

Glib::RefPtr<SourceStyleScheme> SourceBuffer::get_style_scheme()
{

  Glib::RefPtr<SourceStyleScheme> retvalue = Glib::wrap(gtk_source_buffer_get_style_scheme(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const SourceStyleScheme> SourceBuffer::get_style_scheme() const
{
  return const_cast<SourceBuffer*>(this)->get_style_scheme();
}

Glib::RefPtr<SourceMark> SourceBuffer::create_source_mark(const Glib::ustring& name, const Glib::ustring& category, const Gtk::TextIter& where)
{
  return Glib::wrap(gtk_source_buffer_create_source_mark(gobj(), name.c_str(), category.c_str(), where.gobj()));
}

Glib::SListHandle<Glib::RefPtr<SourceMark> > SourceBuffer::get_source_marks_at_line(int line, const Glib::ustring& category) const
{
  return Glib::SListHandle<Glib::RefPtr<SourceMark> >(gtk_source_buffer_get_source_marks_at_line(const_cast<GtkSourceBuffer*>(gobj()), line, category.c_str()), Glib::OWNERSHIP_SHALLOW);
}

Glib::SListHandle<Glib::RefPtr<SourceMark> > SourceBuffer::get_source_marks_at_iter(Gtk::TextIter& iter, const Glib::ustring& category) const
{
  return Glib::SListHandle<Glib::RefPtr<SourceMark> >(gtk_source_buffer_get_source_marks_at_iter(const_cast<GtkSourceBuffer*>(gobj()), iter.gobj(), category.c_str()), Glib::OWNERSHIP_SHALLOW);
}

void SourceBuffer::remove_source_marks(const Gtk::TextIter& start, const Gtk::TextIter& end, const Glib::ustring& category)
{
gtk_source_buffer_remove_source_marks(gobj(), start.gobj(), end.gobj(), category.c_str()); 
}


Glib::SignalProxy2< void,Gtk::TextIter&,Gtk::TextIter& > SourceBuffer::signal_highlight_updated()
{
  return Glib::SignalProxy2< void,Gtk::TextIter&,Gtk::TextIter& >(this, &SourceBuffer_signal_highlight_updated_info);
}


Glib::SignalProxy1< void,const Glib::RefPtr<SourceMark>& > SourceBuffer::signal_source_mark_updated()
{
  return Glib::SignalProxy1< void,const Glib::RefPtr<SourceMark>& >(this, &SourceBuffer_signal_source_mark_updated_info);
}


#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<bool> SourceBuffer::property_highlight_syntax() 
{
  return Glib::PropertyProxy<bool>(this, "highlight-syntax");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> SourceBuffer::property_highlight_syntax() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "highlight-syntax");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<bool> SourceBuffer::property_highlight_matching_brackets() 
{
  return Glib::PropertyProxy<bool>(this, "highlight-matching-brackets");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> SourceBuffer::property_highlight_matching_brackets() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "highlight-matching-brackets");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<int> SourceBuffer::property_max_undo_levels() 
{
  return Glib::PropertyProxy<int>(this, "max-undo-levels");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<int> SourceBuffer::property_max_undo_levels() const
{
  return Glib::PropertyProxy_ReadOnly<int>(this, "max-undo-levels");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< Glib::RefPtr<SourceLanguage> > SourceBuffer::property_language() 
{
  return Glib::PropertyProxy< Glib::RefPtr<SourceLanguage> >(this, "language");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< Glib::RefPtr<SourceLanguage> > SourceBuffer::property_language() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<SourceLanguage> >(this, "language");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> SourceBuffer::property_can_undo() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "can-undo");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> SourceBuffer::property_can_redo() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "can-redo");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< Glib::RefPtr<SourceStyleScheme> > SourceBuffer::property_style_scheme() 
{
  return Glib::PropertyProxy< Glib::RefPtr<SourceStyleScheme> >(this, "style-scheme");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< Glib::RefPtr<SourceStyleScheme> > SourceBuffer::property_style_scheme() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<SourceStyleScheme> >(this, "style-scheme");
}
#endif //GLIBMM_PROPERTIES_ENABLED


#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED


} // namespace gtksourceview


